// ========================== PDF & Spreadsheet Tools ==========================


// ======= Constants =======
const TRADING_PARTNER_DESTINATION_ID = '1KKU7TUn3NrUSGVqKd-lZIpEMWwGQxOOY'; // Destination for copied trading partner PDFs
const SHIPPING_LABEL_DESTINATION_ID = '1YVqcBeCd3aasg-cSxSBLzxqb85sUZcuN'; // Destination for copied shipping label PDFs
const SHIPPING_MANIFEST_DESTINATION_ID = '11jxPplN9wGBIrtkyxUXo5tpaRaTzWX0a'; // Destination for copied shipping manifest PDFs
const DDPOS_FOLDER_ID = '1oQkpJRphGHCtDQEJPKMjOF2o43c8zUIp'; // Replace with DDPOS folder ID
const DIG_DEFENCE_FOLDER_ID = '1YScXpnNqJSjWM4tdxna95YqI0D9hzknJ';



// Trading Partner Folders and Filenames
const tradingPartners = [
  { id: "1ovwLcs_YV2lSjFaYHBPMHo8PIW-_MlnK", filename: "document-PS-amazon" },
  { id: "1Q-jruIpq7B8QtE6yK5Lk0Ti0sSt0V5lD", filename: "document-PS-chewy" },
  { id: "1ITFXqNNBSnTH2NXpH-hgwUADLT03RewS", filename: "document-PS-dd" },
  { id: "1AdT30LJTuoqe3Zc-FLs0GcfS0mSFhkpY", filename: "document-PS-homedepot" },
  { id: "1iw82vvO3jupkbSCC98zInvAFm7_tkIUy", filename: "document-PS-lowes" },
  { id: "1NH19Eiq_Kc5uAEmdijSkuNdYIJYClHCU", filename: "document-PS-menards" },
  { id: "1NU7d8mbYczxAsRMgp26sIIWXAJmIY81w", filename: "document-PS-misc" },
  { id: "1bYgzoAZTIho6T40d0BdRqRpQZy3b1QNF", filename: "document-PS-petco" },
  { id: "1r9hQKTMAHcdGKu_vKLQqqo3fhSpUIdsX", filename: "document-PS-sams" },
  { id: "13NDlqSswGZiZLkmA3eIWf0yIPynxuEdn", filename: "document-PS-sample" },
  { id: "1bj4hvpxThfHjYFOEo6Z21Oz1OUyecE4D", filename: "document-PS-shein" },
  { id: "1wf1b5VjkfLCaFFOW4YLu06Mewx_IKgjr", filename: "document-PS-temu" },
  { id: "1jBh9NiUIBP7lPmTgmRr1GJH7U6KNU4ip", filename: "document-PS-tiktok" },
  { id: "1_6bWlFYtVXaya2LJazaL0hQaDiiNY-gP", filename: "document-PS-tsc" },
  { id: "1IO456og1_zpPphW7Wi0co-V_AA6TXDmU", filename: "document-PS-walmart" },
  { id: "18RJO-_HZVXLT9xkFbHVHG7jYwMLL08QA", filename: "document-PS-wf" },
  { id: "1yzEmFqG-T50m1sao1-f0rzGzH5sXGwc6", filename: "document-PS-wcs" }
];

// Shipping Label Folders and Filenames
const shippingLabelPartners = [
  { id: "1XQPZM7A6X_qBzbmDvYp7NTm5YbQj57Nu", filename: "document-PS-amazon-L" },
  { id: "16Cx9vAtcc9nTDp4VqUnx2Dh-U_m1gIzO", filename: "document-PS-chewy-L" },
  { id: "1uO0XdjcyZoQEsh8e9oClAX3B-2qhAmOU", filename: "document-PS-dd-L" },
  { id: "1NJb3erGUmEn58F_-lQcnUYRT7aJkqrrf", filename: "document-PS-homedepot-L" },
  { id: "1mOUT7ED0_HXoxvB2h32psWNsHDdp7sk8", filename: "document-PS-lowes-L" },
  { id: "15n4b6lN89hyfoJZyh-95WWXkwp3om3Tn", filename: "document-PS-menards-L" },
  { id: "1rqPN32qM6E4JosTz2MUIaFu7SmffcIaV", filename: "document-PS-misc-L" },
  { id: "1Lv1ko6T1iaF_KLfWWINmRawqHzKj9sVR", filename: "document-PS-petco-L" },
  { id: "1e54ohDfqoBpzXgbiVDjDK1vOd0EFzRlH", filename: "document-PS-sample-L" },
  { id: "1VMIJS7rMmiD5LFeRM2Tk-AlBx0Q4xqx9", filename: "document-PS-sams-L" },
  { id: "1s8BR3wrU00El28URuzs5TlxcGarckcCE", filename: "document-PS-shein-L" },
  { id: "166-_f7eSc_3f5wfTmhPeUSpvnpXupWhM", filename: "document-PS-temu-L" },
  { id: "16RrWIl7te5-KiUJPQRTJy9CzxFaGrMx2", filename: "document-PS-tiktok-L" },
  { id: "1KzmYw6ib0iVEKElmF_Zyogz-MRfXJkol", filename: "document-PS-tsc-L" },
  { id: "1aGSbBy7AcwrfUuLkSeL3ajLny1_XTz7P", filename: "document-PS-walmart-L" },
  { id: "1h--ElgLZMh7jnqSq1jepxHnoKQ-7LTNe", filename: "document-PS-wf-L" },
  { id: "1w1aZYMf5BhSvZhMOmPIQJJH9PrfBkBfy", filename: "document-PS-wcs-L" }
];

// Shipping Manifest Folders and Filenames
const shippingManifestPartners = [
  { id: "1BfAbKRGq8qIGT7IznZDS9numy_zx2ELe", filename: "document-PS-amazon-T" },
  { id: "1R7_m9ikTPYQVpf3ZGrsyC5roDtSEWbLN", filename: "document-PS-chewy-T" },
  { id: "1TpO6GbpXeg39MLTOYMPg94Mpw57z3GCp", filename: "document-PS-dd-T" },
  { id: "1V22gTNVIy5lSjTlI2GvYe3J3Uq3juh5H", filename: "document-PS-homedepot-T" },
  { id: "1bQlGZ1NDMBQarYmI3UoDn8U_3LMRZ3Vv", filename: "document-PS-lowes-T" },
  { id: "1MWnzjyQKJScOYEoOUBTWhtREtnkFQzUD", filename: "document-PS-menards-T" },
  { id: "1lmnV0C2MW-zfk2wZX3AUArrOUdm67JMW", filename: "document-PS-misc-T" },
  { id: "1_I-qReisOkz0TTFjcJ9Bphh7q3Ps5Z_G", filename: "document-PS-petco-T" },
  { id: "18vr5SlrIaHnpjcTWPw-NCAffHE5wP7kD", filename: "document-PS-sample-T" },
  { id: "1nLU_ylqhASxeZC2UtYDCAVBMuNEH8dmf", filename: "document-PS-sams-T" },
  { id: "16ZVIpkiWcDIylg5t4v1KXDAIKbnvPoDQ", filename: "document-PS-shein-T" },
  { id: "10-suGsWhIDFx572-1eJHwRSOtJdIo7WH", filename: "document-PS-temu-T" },
  { id: "1v9LPUw3aojyq2T_iO6Xz9KuN4Vly3rr1", filename: "document-PS-tiktok-T" },
  { id: "1VVFW4CMBOZBvHRFOJd36G_-wRBVitnK3", filename: "document-PS-tsc-T" },
  { id: "1LsB_yIh2y4hK1zAMcUl0Y9Pxr7PJTkvt", filename: "document-PS-walmart-T" },
  { id: "15PT6-0zVn9-y_SZs3WeZySK2B11kPE7p", filename: "document-PS-wf-T" },
  { id: "1kiVrEXnrOluFepxdcPGAC4xSNa9Wbc9L", filename: "document-PS-wcs-T" }
];

// ======= Trading Partner PDF Renaming =======
function renameTradingPartnerFiles() {
  let totalFiles = 0;
  tradingPartners.forEach(partner => {
    try {
      Logger.log(`Renaming files in folder ${partner.id}`);
      const folder = DriveApp.getFolderById(partner.id);
      const files = folder.getFilesByType(MimeType.PDF);
      let index = 1;
      while (files.hasNext()) {
        const file = files.next();
        file.setName(`${partner.filename}${index > 1 ? `-${index}` : ''}.pdf`);
        index++;
        totalFiles++;
      }
      Logger.log(`Renamed ${index - 1} files in folder ${partner.id}`);
    } catch (e) {
      Logger.log(`Error renaming in folder ${partner.id}: ${e.message}`);
    }
  });
  return `✅ Renamed ${totalFiles} trading partner PDFs`;
}

// ======= Shipping Labels Renaming =======
function renameShippingLabels() {
  let totalFiles = 0;
  shippingLabelPartners.forEach(partner => {
    try {
      Logger.log(`Renaming shipping labels in folder ${partner.id}`);
      const folder = DriveApp.getFolderById(partner.id);
      const files = folder.getFilesByType(MimeType.PDF);
      let index = 1;
      while (files.hasNext()) {
        const file = files.next();
        file.setName(`${partner.filename}${index > 1 ? `-${index}` : ''}.pdf`);
        index++;
        totalFiles++;
      }
      Logger.log(`Renamed ${index - 1} shipping labels in folder ${partner.id}`);
    } catch (e) {
      Logger.log(`Error renaming in folder ${partner.id}: ${e.message}`);
    }
  });
  return `✅ Renamed ${totalFiles} shipping label PDFs`;
}
// ======= Trading Partner PDF Renaming (Thursday) =======
function renameTradingPartnerFilesThurs() {
  let totalFiles = 0;
  tradingPartners.forEach(partner => {
    try {
      Logger.log(`Renaming Thursday files in folder ${partner.id}`);
      const folder = DriveApp.getFolderById(partner.id);
      const files = folder.getFilesByType(MimeType.PDF);
      let index = 1;
      while (files.hasNext()) {
        const file = files.next();
        file.setName(`${partner.filename}${index > 1 ? `-${index}` : ''}-thurs.pdf`);
        index++;
        totalFiles++;
      }
      Logger.log(`Renamed ${index - 1} Thursday files in folder ${partner.id}`);
    } catch (e) {
      Logger.log(`Error renaming Thursday files in folder ${partner.id}: ${e.message}`);
    }
  });
  return `✅ Renamed ${totalFiles} trading partner PDFs with -thurs suffix`;
}

// ======= Shipping Labels Renaming (Thursday) =======
function renameShippingLabelsThurs() {
  let totalFiles = 0;
  shippingLabelPartners.forEach(partner => {
    try {
      Logger.log(`Renaming Thursday shipping labels in folder ${partner.id}`);
      const folder = DriveApp.getFolderById(partner.id);
      const files = folder.getFilesByType(MimeType.PDF);
      let index = 1;
      while (files.hasNext()) {
        const file = files.next();
        // Remove trailing '-L' from original filename
        const baseName = partner.filename.replace(/-L$/, '');
        file.setName(`${baseName}${index > 1 ? `-${index}` : ''}-thurs-L.pdf`);
        index++;
        totalFiles++;
      }
      Logger.log(`Renamed ${index - 1} Thursday shipping labels in folder ${partner.id}`);
    } catch (e) {
      Logger.log(`Error renaming Thursday labels in folder ${partner.id}: ${e.message}`);
    }
  });
  return `✅ Renamed ${totalFiles} shipping label PDFs with -thurs-L suffix`;
}

// ======= Trading Partner PDF Renaming (Sunday) =======
function renameTradingPartnerFilesSun() {
  let totalFiles = 0;
  tradingPartners.forEach(partner => {
    try {
      Logger.log(`Renaming Sunday files in folder ${partner.id}`);
      const folder = DriveApp.getFolderById(partner.id);
      const files = folder.getFilesByType(MimeType.PDF);
      let index = 1;
      while (files.hasNext()) {
        const file = files.next();
        file.setName(`${partner.filename}${index > 1 ? `-${index}` : ''}-sun.pdf`);
        index++;
        totalFiles++;
      }
      Logger.log(`Renamed ${index - 1} Sunday files in folder ${partner.id}`);
    } catch (e) {
      Logger.log(`Error renaming Sunday files in folder ${partner.id}: ${e.message}`);
    }
  });
  return `✅ Renamed ${totalFiles} trading partner PDFs with -sun suffix`;
}

// ======= Shipping Labels Renaming (Sunday) =======
function renameShippingLabelsSun() {
  let totalFiles = 0;
  shippingLabelPartners.forEach(partner => {
    try {
      Logger.log(`Renaming Sunday shipping labels in folder ${partner.id}`);
      const folder = DriveApp.getFolderById(partner.id);
      const files = folder.getFilesByType(MimeType.PDF);
      let index = 1;
      while (files.hasNext()) {
        const file = files.next();
        // Remove trailing '-L' from original filename
        const baseName = partner.filename.replace(/-L$/, '');
        file.setName(`${baseName}${index > 1 ? `-${index}` : ''}-sun-L.pdf`);
        index++;
        totalFiles++;
      }
      Logger.log(`Renamed ${index - 1} Sunday shipping labels in folder ${partner.id}`);
    } catch (e) {
      Logger.log(`Error renaming Sunday labels in folder ${partner.id}: ${e.message}`);
    }
  });
  return `✅ Renamed ${totalFiles} shipping label PDFs with -sun-L suffix`;
}








// ======= Shipping Manifests Renaming =======
function renameShippingManifestPDFs() {
  let totalFiles = 0;
  shippingManifestPartners.forEach(partner => {
    try {
      Logger.log(`Renaming shipping manifests in folder ${partner.id}`);
      const folder = DriveApp.getFolderById(partner.id);
      const files = folder.getFilesByType(MimeType.PDF);
      let index = 1;
      while (files.hasNext()) {
        const file = files.next();
        file.setName(`${partner.filename}${index > 1 ? `-${index}` : ''}.pdf`);
        index++;
        totalFiles++;
      }
      Logger.log(`Renamed ${index - 1} shipping manifests in folder ${partner.id}`);
    } catch (e) {
      Logger.log(`Error renaming in folder ${partner.id}: ${e.message}`);
    }
  });
  return `✅ Renamed ${totalFiles} shipping manifest PDFs`;
}

// ======= DDPOS Files Renaming =======
function renameDDPOSFiles() {
  try {
    const folder = DriveApp.getFolderById(DDPOS_FOLDER_ID);
    const files = folder.getFilesByType(MimeType.PDF);
    const today = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyy-MM-dd");
    let index = 1;
    let totalFiles = 0;

    while (files.hasNext()) {
      const file = files.next();
      const newName = `${today}-ddpos${index > 1 ? `-${index}` : ''}.pdf`;
      file.setName(newName);
      index++;
      totalFiles++;
    }

    Logger.log(`Renamed ${totalFiles} DDPOS files`);
    return `✅ Renamed ${totalFiles} DDPOS PDFs to ${today}-ddpos*.pdf`;
  } catch (e) {
    Logger.log(`Error renaming DDPOS files: ${e.message}`);
    return `⚠️ Failed to rename DDPOS PDFs: ${e.message}`;
  }
}
// ======= Rename File Ext =======
function renameFileToPDF() {
  // Collect all relevant folder IDs
  const allFolderIds = [
    ...tradingPartners.map(p => p.id),
    ...shippingLabelPartners.map(p => p.id),
    ...shippingManifestPartners.map(p => p.id),
    DDPOS_FOLDER_ID,
    TRADING_PARTNER_DESTINATION_ID,
    SHIPPING_LABEL_DESTINATION_ID,
    SHIPPING_MANIFEST_DESTINATION_ID
  ];

  let totalRenamed = 0;

  allFolderIds.forEach(folderId => {
    try {
      const folder = DriveApp.getFolderById(folderId);
      const files = folder.getFiles();

      while (files.hasNext()) {
        const file = files.next();
        const name = file.getName();

        // Skip folders and files that already have an extension
        if (!name.includes('.')) {
          const newName = `${name}.pdf`;
          file.setName(newName);
          totalRenamed++;
          Logger.log(`Renamed "${name}" to "${newName}" in folder ${folderId}`);
        }
      }
    } catch (e) {
      Logger.log(`Error processing folder ${folderId}: ${e.message}`);
    }
  });

  return `✅ Renamed ${totalRenamed} file(s) to add .pdf extension`;
}

// ======= Copy Trading Partner PDFs =======
function copyTradingPartnerPDFs() {
  let totalFiles = 0;
  try {
    Logger.log(`Copying to destination folder ${TRADING_PARTNER_DESTINATION_ID}`);
    const destFolder = DriveApp.getFolderById(TRADING_PARTNER_DESTINATION_ID);
    tradingPartners.forEach(partner => {
      try {
        Logger.log(`Copying from folder ${partner.id}`);
        const sourceFolder = DriveApp.getFolderById(partner.id);
        const files = sourceFolder.getFilesByType(MimeType.PDF);
        let index = 1;
        while (files.hasNext()) {
          const file = files.next();
          file.makeCopy(`${file.getName()}${index > 1 ? `-${index}` : ''}`, destFolder);
          index++;
          totalFiles++;
        }
        Logger.log(`Copied ${index - 1} files from folder ${partner.id}`);
      } catch (e) {
        Logger.log(`Error copying from folder ${partner.id}: ${e.message}`);
      }
    });
    return `✅ Copied ${totalFiles} trading partner PDFs to destination folder`;
  } catch (e) {
    Logger.log(`Error accessing destination folder ${TRADING_PARTNER_DESTINATION_ID}: ${e.message}`);
    return `⚠️ Failed to copy trading partner PDFs: ${e.message}`;
  }
}

// ======= Copy Shipping Label PDFs =======
function copyShippingLabelPDFs() {
  let totalFiles = 0;
  try {
    Logger.log(`Copying to destination folder ${SHIPPING_LABEL_DESTINATION_ID}`);
    const destFolder = DriveApp.getFolderById(SHIPPING_LABEL_DESTINATION_ID);
    shippingLabelPartners.forEach(partner => {
      try {
        Logger.log(`Copying from folder ${partner.id}`);
        const sourceFolder = DriveApp.getFolderById(partner.id);
        const files = sourceFolder.getFilesByType(MimeType.PDF);
        let index = 1;
        while (files.hasNext()) {
          const file = files.next();
          file.makeCopy(`${file.getName()}${index > 1 ? `-${index}` : ''}`, destFolder);
          index++;
          totalFiles++;
        }
        Logger.log(`Copied ${index - 1} files from folder ${partner.id}`);
      } catch (e) {
        Logger.log(`Error copying from folder ${partner.id}: ${e.message}`);
      }
    });
    return `✅ Copied ${totalFiles} shipping label PDFs to destination folder`;
  } catch (e) {
    Logger.log(`Error accessing destination folder ${SHIPPING_LABEL_DESTINATION_ID}: ${e.message}`);
    return `⚠️ Failed to copy shipping label PDFs: ${e.message}`;
  }
}

// ======= Copy Shipping Manifest PDFs =======
function copyShippingManifestPDFs() {
  let totalFiles = 0;
  try {
    Logger.log(`Copying to destination folder ${SHIPPING_MANIFEST_DESTINATION_ID}`);
    const destFolder = DriveApp.getFolderById(SHIPPING_MANIFEST_DESTINATION_ID);
    shippingManifestPartners.forEach(partner => {
      try {
        Logger.log(`Copying from folder ${partner.id}`);
        const sourceFolder = DriveApp.getFolderById(partner.id);
        const files = sourceFolder.getFilesByType(MimeType.PDF);
        let index = 1;
        while (files.hasNext()) {
          const file = files.next();
          file.makeCopy(`${file.getName()}${index > 1 ? `-${index}` : ''}`, destFolder);
          index++;
          totalFiles++;
        }
        Logger.log(`Copied ${index - 1} files from folder ${partner.id}`);
      } catch (e) {
        Logger.log(`Error copying from folder ${partner.id}: ${e.message}`);
      }
    });
    return `✅ Copied ${totalFiles} shipping manifest PDFs to destination folder`;
  } catch (e) {
    Logger.log(`Error accessing destination folder ${SHIPPING_MANIFEST_DESTINATION_ID}: ${e.message}`);
    return `⚠️ Failed to copy shipping manifest PDFs: ${e.message}`;
  }
}

// ======= Moving Shipping Docs =======
function prepareShippingDocuments() {
  try {
    const SOURCE_FOLDERS = [
      "1oQkpJRphGHCtDQEJPKMjOF2o43c8zUIp", // Final PO PDF Folder
      "1YVqcBeCd3aasg-cSxSBLzxqb85sUZcuN"  // All Combined Labels Folder
    ];
    const DESTINATION_FOLDER_ID = "148LZNOxM1T5dojvNj5Zi7Y4zbsmZUDwK";
    const destination = DriveApp.getFolderById(DESTINATION_FOLDER_ID);
    let totalCopied = 0;

    SOURCE_FOLDERS.forEach(folderId => {
      const folder = DriveApp.getFolderById(folderId);
      const files = folder.getFilesByType(MimeType.PDF);

      while (files.hasNext()) {
        const file = files.next();
        file.makeCopy(file.getName(), destination);
        totalCopied++;
      }
    });

    Logger.log(`Copied ${totalCopied} PDF(s) to destination folder`);
    return `✅ ${totalCopied} PDF(s) copied to Shipping Documents folder`;
  } catch (e) {
    Logger.log(`Error in prepareShippingDocuments: ${e.message}`);
    return `⚠️ Failed to prepare shipping documents: ${e.message}`;
  }
}

// ======= Email Prep =======
function emailPrep() {
  try {
    // === Folder IDs ===
    const sourceFolders = [
      "1KKU7TUn3NrUSGVqKd-lZIpEMWwGQxOOY", // All Combined Packing Slips Folder
      "1YVqcBeCd3aasg-cSxSBLzxqb85sUZcuN"  // All Combined Labels Folder
    ];

    const destinationFolders = [
      "148LZNOxM1T5dojvNj5Zi7Y4zbsmZUDwK", // PO Production Folder
      "16L13SDR6_bCFs_r6trB74GNnL4GwfxY-"  // 1st Previous Day Folder, adds a copy for backup
    ];

    let totalCopied = 0;

    // === Iterate over source folders ===
    sourceFolders.forEach(sourceId => {
      const sourceFolder = DriveApp.getFolderById(sourceId);
      const files = sourceFolder.getFilesByType(MimeType.PDF);

      // For each file, copy to each destination
      while (files.hasNext()) {
        const file = files.next();

        destinationFolders.forEach(destId => {
          const destFolder = DriveApp.getFolderById(destId);

          // If a file with the same name exists, remove it first
          const existingFiles = destFolder.getFilesByName(file.getName());
          while (existingFiles.hasNext()) {
            existingFiles.next().setTrashed(true);
          }

          // Copy the file
          file.makeCopy(file.getName(), destFolder);
          totalCopied++;
        });
      }
    });

    const msg = `✅ Copied ${totalCopied} PDF(s) to both destination folders.`;
    Logger.log(msg);
    return msg;

  } catch (e) {
    const errMsg = `⚠️ emailPrep() failed: ${e.message}`;
    Logger.log(errMsg);
    return errMsg;
  }
}

// ======= Purge All PDFs =======
function purgeAllPDFs() {
  const allFolderIds = new Set([
    ...tradingPartners.map(p => p.id),
    ...shippingLabelPartners.map(p => p.id),
    ...shippingManifestPartners.map(p => p.id),
    DDPOS_FOLDER_ID,
    TRADING_PARTNER_DESTINATION_ID,
    SHIPPING_LABEL_DESTINATION_ID,
    SHIPPING_MANIFEST_DESTINATION_ID
  ]);

  let totalDeleted = 0;

  allFolderIds.forEach(id => {
    if (id && !id.match(/^(YOUR_|DDPOS_)/)) {
      try {
        const folder = DriveApp.getFolderById(id);
        const files = folder.getFiles();
        let count = 0;
        while (files.hasNext()) {
          files.next().setTrashed(true);
          count++;
        }
        totalDeleted += count;
      } catch (e) {
        Logger.log(`Skipped folder ${id}: ${e.message}`);
      }
    } else {
      Logger.log(`Skipped invalid or placeholder folder ID: ${id}`);
    }
  });

  return `✅ Purged ${totalDeleted} file(s) from all PDF folders`;
}

// ======= Purge Daily PDFs =======
function purgeDailyShippingDocs() {
  try {
    const FOLDER_ID = "148LZNOxM1T5dojvNj5Zi7Y4zbsmZUDwK";
    const folder = DriveApp.getFolderById(FOLDER_ID);
    const files = folder.getFiles(); // all files, not just PDFs
    let totalDeleted = 0;

    while (files.hasNext()) {
      const file = files.next();
      Logger.log(`Deleting: ${file.getName()}`);
      file.setTrashed(true);
      totalDeleted++;
    }

    Logger.log(`Purged ${totalDeleted} file(s) from Daily Shipping Docs folder`);
    return `✅ Purged ${totalDeleted} file(s) from Daily Shipping Docs folder`;
  } catch (e) {
    Logger.log(`Error in purgeDailyShippingDocs: ${e.message}`);
    return `⚠️ Failed to purge Daily Shipping Docs: ${e.message}`;
  }
}



// ======= Menards Shipping Extraction Script =======
// ======= Menards Shipping Extraction Script =======
// ======= Menards Shipping Extraction Script =======
// ======= Menards Shipping Extraction Script =======



/**
 * Configuration settings for the script.
 * @const
 */
const CONFIG = {
  FOLDER_ID: '1NH19Eiq_Kc5uAEmdijSkuNdYIJYClHCU',
  SHEET_ID: '18S8eTH-OLVJwJSS7fZo6UD6Ut2TAtSSMDCFtHxDZahY',
  SHEET_NAME: 'Sheet1',
  SKU_MAP: {
    '2-4':   { internalSKU: 'DD2083204',  weight: 8.5 },
    '2-10':  { internalSKU: 'DD2083210',  weight: 20 },
    '2-25':  { internalSKU: 'DD2083225',  weight: 49 },
    '3-4':   { internalSKU: 'DD3103204',  weight: 8.8 },
    '3-10':  { internalSKU: 'DD3103210',  weight: 20.4 },
    '3-25':  { internalSKU: 'DD3103225',  weight: 49.8 },
    'XL-2':  { internalSKU: 'DDXL152402', weight: 7.6 },
    'XL-5':  { internalSKU: 'DDXL152405', weight: 18 },
    'XL-15': { internalSKU: 'DDXL152415', weight: 52.5 },
  },
};

/**
 * Main function to process Menards PDFs from a Drive folder and log data to a Sheet.
 */
function extractMenardsShippingData() {
  const sheet = SpreadsheetApp.openById(CONFIG.SHEET_ID).getSheetByName(CONFIG.SHEET_NAME);
  sheet.clear();

  const headers = [
    'PKG_PACKAGE_ID', 'SHPTO_NAME', 'SHPTO_ADDRESS_1', 'SHPTO_ADDRESS_2', 'SHPTO_ADDRESS_3',
    'SHPTO_CITY', 'SHPTO_STATE_PROV', 'SHPTO_POSTAL_CODE', 'SHPTO_COUNTRY_ID', 'PKG_TELEPHONE',
    'PKG_SERVICE_TYPE', 'PKG_WEIGHT_ACTUAL', 'PKG_CUSTOM1', 'PKG_CUSTOM2', 'PKG_CUSTOM3',
    'PKG_CUSTOM4', 'PKG_CUSTOM5', 'SHPTO_RESIDENTIAL', 'UOL_SOURCE', 'SHPTO_ATTN_LINE',
    'SHPTO_COMPANY', 'MERCHANT_ID',
  ];
  sheet.appendRow(headers);

  const folder = DriveApp.getFolderById(CONFIG.FOLDER_ID);
  const files = folder.getFilesByType(MimeType.PDF);
  let processedCount = 0;

  while (files.hasNext()) {
    const file = files.next();
    const poNumber = file.getName().replace(/\.pdf$/i, '');
    let ocrFileId = null;

    try {
      const text = getOcrText_(file);
      ocrFileId = text.tempDocId;

      const shipToData = parseShipToBlock_(text.content);
      const lineItems = parseLineItems_(text.content);
      
      if (lineItems.length === 0) {
        throw new Error('No line items could be parsed from the PDF.');
      }

      for (const item of lineItems) {
        const rowData = [
          poNumber, shipToData.name, shipToData.address, '', '', shipToData.city, shipToData.state, shipToData.postal, 'US', shipToData.phone,
          'STANDARD', item.weight, item.internalSku, poNumber, '', poNumber, item.quantity, 'N', '', shipToData.name, shipToData.name, 'menards',
        ];
        sheet.appendRow(rowData);
      }
      processedCount++;

    } catch (e) {
      Logger.log(`Error processing ${file.getName()}: ${e.message}`);
      sheet.appendRow([poNumber, `ERROR: ${e.message}`]);
    } finally {
      if (ocrFileId) {
        Drive.Files.remove(ocrFileId);
      }
    }
  }
  Logger.log(`✅ Extracted shipping info from ${processedCount} PDF(s).`);
}

/**
 * Extracts text from a PDF file using OCR, with a retry mechanism for API errors.
 * @param {GoogleAppsScript.Drive.File} file The PDF file to process.
 * @return {{content: string, tempDocId: string}} An object with the extracted text and temp file ID.
 * @private
 */
function getOcrText_(file) {
  const resource = { title: `temp-ocr-${file.getName()}`, mimeType: MimeType.GOOGLE_DOCS };
  let ocrFile;

  // Try the API call up to 3 times.
  for (let i = 0; i < 3; i++) {
    try {
      ocrFile = Drive.Files.create(resource, file.getBlob(), { ocr: true });
      // If the call is successful, break out of the retry loop.
      break;
    } catch (e) {
      Logger.log(`API call failed on attempt ${i + 1}. Retrying in 2 seconds. Error: ${e.message}`);
      // If this was the last attempt, give up and throw the error.
      if (i === 2) {
        throw e;
      }
      // Wait for 2 seconds before the next attempt.
      Utilities.sleep(2000);
    }
  }

  const doc = DocumentApp.openById(ocrFile.id);
  const text = doc.getBody().getText();
  return { content: text, tempDocId: ocrFile.id };
}

/**
 * Parses the "Ship To" block from the OCR text to extract address details.
 * @param {string} text The full text content from the PDF.
 * @return {{name: string, address: string, city: string, state: string, postal: string, phone: string}} The parsed address information.
 * @private
 */
function parseShipToBlock_(text) {
  const data = { name: '', address: '', city: '', state: '', postal: '', phone: '' };
  const match = text.match(/Ship To:\s*([\s\S]*?)(?=Guest Information:|Bill To:)/i);

  if (match && match[1]) {
    const lines = match[1].split('\n').map(line => line.trim()).filter(Boolean);
    const cszIndex = lines.findIndex(line => /,\s*[A-Z]{2}\s*\d{5}/.test(line));
    const phoneIndex = lines.findIndex(line => /Phone:/.test(line));
    const nameLine = lines.find((line, index) => {
      return index !== cszIndex && index !== phoneIndex && /^[A-Z\s]+$/i.test(line) && !/^\d{4}$/.test(line);
    });
    data.name = nameLine || '';
    if (cszIndex !== -1) {
      const cszMatch = lines[cszIndex].match(/(.+?),\s*([A-Z]{2})\s*(\d{5}(?:-\d{4})?)/);
      if (cszMatch) {
        let potentialCityAndAddress = cszMatch[1].trim();
        data.state = cszMatch[2].trim();
        data.postal = cszMatch[3].trim();
        if (/\d/.test(potentialCityAndAddress) && data.name) {
          const parts = potentialCityAndAddress.split(new RegExp(`\\s+${data.name}$`, 'i'));
          data.address = parts[0].trim();
          data.city = data.name;
        } else {
          data.city = potentialCityAndAddress;
        }
      }
    }
    if (phoneIndex !== -1) {
      const phoneMatch = lines[phoneIndex].match(/Phone:\s*([\d-]+)/i);
      if(phoneMatch) data.phone = phoneMatch[1].trim();
    }
    if (!data.address) {
      const addressLine = lines.find(line => /\d/.test(line) && !line.includes(data.postal) && !/Phone:/.test(line) && !/^\d{4}$/.test(line));
      if(addressLine) data.address = addressLine;
    }
  }
  return data;
}

/**
 * Parses all line items from the OCR text.
 * @param {string} text The full text content from the PDF.
 * @return {Array<Object>} A list of item objects, each with vendorSku, internalSku, quantity, and weight.
 * @private
 */
function parseLineItems_(text) {
  const items = [];
  // This final regex is built based on the actual OCR output from the log.
  const itemRegex = /1002485\s+DIGDE001 Special Order\s+(\d+)\s+[\d,.]+\s+Package\s+[\d,.]+\s+Vendor Part #:\s*([\w-]+)/g;
  let match;

  while ((match = itemRegex.exec(text)) !== null) {
    // NOTE: The capture group order has changed.
    // match[1] is now the Quantity.
    // match[2] is now the Vendor SKU.
    const quantity = match[1].trim();
    const vendorSku = match[2].trim();
    const mappedSku = CONFIG.SKU_MAP[vendorSku] || { internalSKU: `NOT_FOUND: ${vendorSku}`, weight: '' };

    items.push({
      vendorSku: vendorSku,
      quantity: quantity,
      internalSku: mappedSku.internalSKU,
      weight: mappedSku.weight
    });
  }
  return items;
}

// ======= WCS Shipping Extraction Script =======
// ======= WCS Shipping Extraction Script =======
// ======= WCS Shipping Extraction Script =======
// ======= WCS Shipping Extraction Script =======
// ======= WCS Shipping Extraction Script =======


/**
 * Configuration settings for the WCS script.
 * @const
 */
const CONFIG_WCS = {
  FOLDER_ID: '1yzEmFqG-T50m1sao1-f0rzGzH5sXGwc6',
  SHEET_ID: '18S8eTH-OLVJwJSS7fZo6UD6Ut2TAtSSMDCFtHxDZahY',
  SHEET_NAME: 'Sheet1',
  SKU_MAP: {
    'DDAC-Tool-C': { internalSKU: 'DDAC-TOOL',  weight: 19.9 },
  },
};

/**
 * Main function to process WCS PDFs from a Drive folder and log data to a Sheet.
 */
function extractWCSData() {
  const sheet = SpreadsheetApp.openById(CONFIG_WCS.SHEET_ID).getSheetByName(CONFIG_WCS.SHEET_NAME) || 
                SpreadsheetApp.openById(CONFIG_WCS.SHEET_ID).insertSheet(CONFIG_WCS.SHEET_NAME);
  sheet.clear();

  const headers = [
    'PKG_PACKAGE_ID', 'SHPTO_NAME', 'SHPTO_ADDRESS_1', 'SHPTO_ADDRESS_2', 'SHPTO_ADDRESS_3',
    'SHPTO_CITY', 'SHPTO_STATE_PROV', 'SHPTO_POSTAL_CODE', 'SHPTO_COUNTRY_ID', 'PKG_TELEPHONE',
    'PKG_SERVICE_TYPE', 'PKG_WEIGHT_ACTUAL', 'PKG_CUSTOM1', 'PKG_CUSTOM2', 'PKG_CUSTOM3',
    'PKG_CUSTOM4', 'PKG_CUSTOM5', 'SHPTO_RESIDENTIAL', 'UOL_SOURCE', 'SHPTO_ATTN_LINE',
    'SHPTO_COMPANY', 'MERCHANT_ID',
  ];
  sheet.appendRow(headers);

  // This helper function is assumed to exist from the previous Menards script
  // If it doesn't, you would need to include it in your script file.
  if (typeof getOcrText_ === 'undefined') {
    throw new Error('The helper function getOcrText_ is missing from your script file.');
  }

  const folder = DriveApp.getFolderById(CONFIG_WCS.FOLDER_ID);
  const files = folder.getFilesByType(MimeType.PDF);
  let processedCount = 0;

  while (files.hasNext()) {
    const file = files.next();
    let ocrFileId = null;

    try {
      const text = getOcrText_(file); 
      ocrFileId = text.tempDocId;

      const poNumberMatch = text.content.match(/PO #\s*(\w+)/);
      const poNumber = poNumberMatch ? poNumberMatch[1] : `NO_PO_FOUND_IN_${file.getName()}`;
      
      const shipToData = parseWCSShipToBlock_(text.content);
      const lineItems = parseWCSLineItems_(text.content);
      
      if (lineItems.length === 0) {
        throw new Error('No line items could be parsed.');
      }

      for (const item of lineItems) {
        const rowData = [
          poNumber, shipToData.name, shipToData.address1, shipToData.address2, '', 
          shipToData.city, shipToData.state, shipToData.postal, 'US', shipToData.phone,
          'STANDARD', item.weight, item.internalSku, poNumber, '', poNumber, item.quantity, 
          'Y', '', shipToData.name, shipToData.company, 'wcs',
        ];
        sheet.appendRow(rowData);
      }
      processedCount++;

    } catch (e) {
      Logger.log(`Error processing ${file.getName()}: ${e.message}`);
      sheet.appendRow([file.getName(), `ERROR: ${e.message}`]);
    } finally {
      if (ocrFileId) {
        Drive.Files.remove(ocrFileId);
      }
    }
  }
  Logger.log(`✅ Extracted shipping info from ${processedCount} WCS PDF(s).`);
}


/**
 * Parses the WCS "Ship To" block from OCR text by finding the block between "Prepared By" and "Memo".
 * @param {string} text The full text content from the PDF.
 * @return {Object} The parsed address information.
 * @private
 */
function parseWCSShipToBlock_(text) {
  const data = { name: '', company: '', address1: '', address2: '', city: '', state: '', postal: '', phone: '' };
  // New, more reliable regex to find the correct address block.
  const shipToMatch = text.match(/Prepared By:[\s\S]*?\n([\s\S]*?)(?=Memo|Customer Phone|Item Code)/);
  
  if (shipToMatch && shipToMatch[1]) {
    const lines = shipToMatch[1].split('\n').map(l => l.trim()).filter(Boolean);
    
    const phoneMatch = text.match(/Customer Phone\s*([\d\(\)\s-]+)/);
    if(phoneMatch) data.phone = phoneMatch[1].trim();

    const cszLine = lines.find(l => /[A-Z]{2}\s+\d{5}/.test(l));
    if (cszLine) {
      const cszMatch = cszLine.match(/(.+?)\s+([A-Z]{2})\s+(\d{5}(?:-\d{4})?)/);
      if (cszMatch) {
          data.city = cszMatch[1].trim();
          data.state = cszMatch[2].trim();
          data.postal = cszMatch[3].trim();
      }
    }
    
    // Process remaining lines for name, company, and address
    const addressLines = lines.filter(l => l !== cszLine && l !== 'United States');
    data.name = addressLines.shift() || '';
    
    // Check if the next line looks like a company name (doesn't start with a number or contain address keywords)
    if (addressLines.length > 0 && !/^\d/.test(addressLines[0]) && !/rd|st|ln|blvd|rd/i.test(addressLines[0])) {
      data.company = addressLines.shift() || '';
    }

    data.address1 = addressLines.shift() || '';
    data.address2 = addressLines.join(' '); 
  }
  return data;
}

/**
 * Parses all WCS line items from the OCR text using a columnar approach.
 * @param {string} text The full text content from the PDF.
 * @return {Array<Object>} A list of item objects.
 * @private
 */
function parseWCSLineItems_(text) {
  const items = [];
  const itemCodeBlockMatch = text.match(/Item Code\s*([\s\S]*?)\s*Quantity/);
  const quantityBlockMatch = text.match(/Quantity\s*([\s\S]*?)\s*Description/);

  if (itemCodeBlockMatch && quantityBlockMatch) {
    const itemCodes = itemCodeBlockMatch[1].match(/(DDAC-Tool-C|Shipping-PO Drop)/g) || [];
    const quantities = quantityBlockMatch[1].split('\n').map(l => l.trim()).filter(Boolean);

    if (itemCodes.length > 0 && itemCodes.length === quantities.length) {
      for (let i = 0; i < itemCodes.length; i++) {
        const itemCode = itemCodes[i];
        const quantity = quantities[i];
        
        if (itemCode === 'Shipping-PO Drop') continue;
        
        const mappedSku = CONFIG_WCS.SKU_MAP[itemCode] || { internalSKU: `NOT_FOUND: ${itemCode}`, weight: '' };

        items.push({
          itemCode: itemCode,
          quantity: quantity,
          internalSku: mappedSku.internalSKU,
          weight: mappedSku.weight
        });
      }
    }
  }
  return items;
}







// ======= HTML Service Entrypoint =======
function doGet() {
  return HtmlService.createHtmlOutputFromFile('index')
    .setTitle('PDF and Spreadsheet Tools')
    .setWidth(600)
    .setHeight(400)
    .setSandboxMode(HtmlService.SandboxMode.IFRAME);
}
