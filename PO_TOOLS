// ======= HTML Service Entrypoint =======
function doGet() {
  return HtmlService.createHtmlOutputFromFile('index')
    .setTitle('PDF and Spreadsheet Tools')
    .setWidth(600)
    .setHeight(400)
    .setSandboxMode(HtmlService.SandboxMode.IFRAME);
}

// =======================================================
// ====== GLOBAL CONSTANTS & CONFIGURATION ======
// =======================================================

// --- General Folder IDs ---
const TRADING_PARTNER_DESTINATION_ID = '1KKU7TUn3NrUSGVqKd-lZIpEMWwGQxOOY'; // Destination for copied trading partner PDFs
const SHIPPING_LABEL_DESTINATION_ID = '1YVqcBeCd3aasg-cSxSBLzxqb85sUZcuN'; // Destination for copied shipping label PDFs
const SHIPPING_MANIFEST_DESTINATION_ID = '11jxPplN9wGBIrtkyxUXo5tpaRaTzWX0a'; // Destination for copied shipping manifest PDFs
const DDPOS_FOLDER_ID = '1oQkpJRphGHCtDQEJPKMjOF2o43c8zUIp';                 // DDPOS folder ID (Used by renameDDPOSFiles, may also be PO destination for splitter)
const DIG_DEFENCE_FOLDER_ID = '1YScXpnNqJSjWM4tdxna95YqI0D9hzknJ';           // Dig Defence folder ID (Usage not clear from provided functions)

const MENARDS_SHIPPING_CONFIG = {
  SHEET_ID: "18S8eTH-OLVJwJSS7fZo6UD6Ut2TAtSSMDCFtHxDZahY",
  SHEET_NAME: "Sheet1",
  FOLDER_ID: "1NH19Eiq_Kc5uAEmdijSkuNdYIJYClHCU",

  // --- ADD THESE TWO LINES ---
  LABEL_TEMPLATE_ID: "1ZA4oFHOzp4iF8fmKUBuCTHjF-AVXMjTl2oS3PMTIOvg",
  LABEL_SAVE_FOLDER_ID: "1xCOFzeAhfPqBoYIum5WVca2kSB0wUL14"
  // ... any other properties you have ...
};



// --- Trading Partner Source Folders ---
const tradingPartners = [
  { id: "1ovwLcs_YV2lSjFaYHBPMHo8PIW-_MlnK", filename: "document-PS-amazon" },
  { id: "1Q-jruIpq7B8QtE6yK5Lk0Ti0sSt0V5lD", filename: "document-PS-chewy" },
  { id: "1ITFXqNNBSnTH2NXpH-hgwUADLT03RewS", filename: "document-PS-dd" },
  { id: "1AdT30LJTuoqe3Zc-FLs0GcfS0mSFhkpY", filename: "document-PS-homedepot" },
  { id: "1iw82vvO3jupkbSCC98zInvAFm7_tkIUy", filename: "document-PS-lowes" },
  { id: "1NH19Eiq_Kc5uAEmdijSkuNdYIJYClHCU", filename: "document-PS-menards" },
  { id: "1NU7d8mbYczxAsRMgp26sIIWXAJmIY81w", filename: "document-PS-misc" },
  { id: "1bYgzoAZTIho6T40d0BdRqRpQZy3b1QNF", filename: "document-PS-petco" },
  { id: "1r9hQKTMAHcdGKu_vKLQqqo3fhSpUIdsX", filename: "document-PS-sams" },
  { id: "13NDlqSswGZiZLkmA3eIWf0yIPynxuEdn", filename: "document-PS-sample" },
  { id: "1bj4hvpxThfHjYFOEo6Z21Oz1OUyecE4D", filename: "document-PS-shein" },
  { id: "1wf1b5VjkfLCaFFOW4YLu06Mewx_IKgjr", filename: "document-PS-temu" },
  { id: "1jBh9NiUIBP7lPmTgmRr1GJH7U6KNU4ip", filename: "document-PS-tiktok" },
  { id: "1_6bWlFYtVXaya2LJazaL0hQaDiiNY-gP", filename: "document-PS-tsc" },
  { id: "1IO456og1_zpPphW7Wi0co-V_AA6TXDmU", filename: "document-PS-walmart" },
  { id: "18RJO-_HZVXLT9xkFbHVHG7jYwMLL08QA", filename: "document-PS-wf" },
  { id: "1yzEmFqG-T50m1sao1-f0rzGzH5sXGwc6", filename: "document-PS-wcs" }
];

// --- Shipping Label Source Folders ---
const shippingLabelPartners = [
  { id: "1XQPZM7A6X_qBzbmDvYp7NTm5YbQj57Nu", filename: "document-PS-amazon-L" },
  { id: "16Cx9vAtcc9nTDp4VqUnx2Dh-U_m1gIzO", filename: "document-PS-chewy-L" },
  { id: "1uO0XdjcyZoQEsh8e9oClAX3B-2qhAmOU", filename: "document-PS-dd-L" },
  { id: "1NJb3erGUmEn58F_-lQcnUYRT7aJkqrrf", filename: "document-PS-homedepot-L" },
  { id: "1mOUT7ED0_HXoxvB2h32psWNsHDdp7sk8", filename: "document-PS-lowes-L" },
  { id: "15n4b6lN89hyfoJZyh-95WWXkwp3om3Tn", filename: "document-PS-menards-L" },
  { id: "1rqPN32qM6E4JosTz2MUIaFu7SmffcIaV", filename: "document-PS-misc-L" },
  { id: "1Lv1ko6T1iaF_KLfWWINmRawqHzKj9sVR", filename: "document-PS-petco-L" },
  { id: "1e54ohDfqoBpzXgbiVDjDK1vOd0EFzRlH", filename: "document-PS-sample-L" },
  { id: "1VMIJS7rMmiD5LFeRM2Tk-AlBx0Q4xqx9", filename: "document-PS-sams-L" },
  { id: "1s8BR3wrU00El28URuzs5TlxcGarckcCE", filename: "document-PS-shein-L" },
  { id: "166-_f7eSc_3f5wfTmhPeUSpvnpXupWhM", filename: "document-PS-temu-L" },
  { id: "16RrWIl7te5-KiUJPQRTJy9CzxFaGrMx2", filename: "document-PS-tiktok-L" },
  { id: "1KzmYw6ib0iVEKElmF_Zyogz-MRfXJkol", filename: "document-PS-tsc-L" },
  { id: "1aGSbBy7AcwrfUuLkSeL3ajLny1_XTz7P", filename: "document-PS-walmart-L" },
  { id: "1h--ElgLZMh7jnqSq1jepxHnoKQ-7LTNe", filename: "document-PS-wf-L" },
  { id: "1w1aZYMf5BhSvZhMOmPIQJJH9PrfBkBfy", filename: "document-PS-wcs-L" }
];

// --- Shipping Manifest Source Folders ---
const shippingManifestPartners = [
  { id: "1BfAbKRGq8qIGT7IznZDS9numy_zx2ELe", filename: "document-PS-amazon-T" },
  { id: "1R7_m9ikTPYQVpf3ZGrsyC5roDtSEWbLN", filename: "document-PS-chewy-T" },
  { id: "1TpO6GbpXeg39MLTOYMPg94Mpw57z3GCp", filename: "document-PS-dd-T" },
  { id: "1V22gTNVIy5lSjTlI2GvYe3J3Uq3juh5H", filename: "document-PS-homedepot-T" },
  { id: "1bQlGZ1NDMBQarYmI3UoDn8U_3LMRZ3Vv", filename: "document-PS-lowes-T" },
  { id: "1MWnzjyQKJScOYEoOUBTWhtREtnkFQzUD", filename: "document-PS-menards-T" },
  { id: "1lmnV0C2MW-zfk2wZX3AUArrOUdm67JMW", filename: "document-PS-misc-T" },
  { id: "1_I-qReisOkz0TTFjcJ9Bphh7q3Ps5Z_G", filename: "document-PS-petco-T" },
  { id: "18vr5SlrIaHnpjcTWPw-NCAffHE5wP7kD", filename: "document-PS-sample-T" },
  { id: "1nLU_ylqhASxeZC2UtYDCAVBMuNEH8dmf", filename: "document-PS-sams-T" },
  { id: "16ZVIpkiWcDIylg5t4v1KXDAIKbnvPoDQ", filename: "document-PS-shein-T" },
  { id: "10-suGsWhIDFx572-1eJHwRSOtJdIo7WH", filename: "document-PS-temu-T" },
  { id: "1v9LPUw3aojyq2T_iO6Xz9KuN4Vly3rr1", filename: "document-PS-tiktok-T" },
  { id: "1VVFW4CMBOZBvHRFOJd36G_-wRBVitnK3", filename: "document-PS-tsc-T" },
  { id: "1LsB_yIh2y4hK1zAMcUl0Y9Pxr7PJTkvt", filename: "document-PS-walmart-T" },
  { id: "15PT6-0zVn9-y_SZs3WeZySK2B11kPE7p", filename: "document-PS-wf-T" },
  { id: "1kiVrEXnrOluFepxdcPGAC4xSNa9Wbc9L", filename: "document-PS-wcs-T" }
];

// -------------------------------------------
// --- Configuration for PDF Splitting (sosSplit function) ---
// -------------------------------------------
const PROJECT_KEY = 'project_public_37a5967de1bae9e416b749063108be66_0wJhvdcca3bb4abecc4f04066775304a80871'; // iLovePDF Project Key
const SECRET_KEY = 'secret_key_4615bfe73bc5142a6cf155654b86d8c4_6kH-_6f48cce83a8bb20792b68acaffa3dae1';   // iLovePDF Secret Key
const SOURCE_FOLDER_URL_FOR_SPLITTING = 'https://drive.google.com/drive/folders/1iw82vvO3jupkbSCC98zInvAFm7_tkIUy'; // Folder to scan for files to split (e.g., Lowes)
const DEST_FOLDER_URL_FOR_SOS = 'https://drive.google.com/drive/folders/148LZNOxM1T5dojvNj5Zi7Y4zbsmZUDwK';       // Folder to save SOS labels
const DELETE_ORIGINAL_AFTER_SPLIT = true;           // Delete original after successful split? (true/false)
const PO_KEYWORD = "PO Number:";                    // Keyword to identify PO pages
const SOS_KEYWORD = "SOS";                          // Keyword to identify SOS pages


// Generate JWT for iLovePDF operations
function generateILovePDFJwt_() {
  const header = { alg: "HS256", typ: "JWT" };
  const payload = { // optional payload for task creation
    exp: Math.floor(Date.now() / 1000) + 60*60, // 1 hour expiry
  };
  const encodedHeader = Utilities.base64EncodeWebSafe(JSON.stringify(header));
  const encodedPayload = Utilities.base64EncodeWebSafe(JSON.stringify(payload));
  const signature = Utilities.computeHmacSha256Signature(encodedHeader + "." + encodedPayload, SECRET_KEY);
  const encodedSignature = Utilities.base64EncodeWebSafe(signature);
  return `${encodedHeader}.${encodedPayload}.${encodedSignature}`;
}


// Optional: Folder to save POs if you DON'T want them saved back to the source folder.
// const DEST_FOLDER_URL_FOR_POS = 'https://drive.google.com/drive/folders/1oQkpJRphGHCtDQEJPKMjOF2o43c8zUIp'; // DDPOS folder - only needed if sosSplit saves POs here


// -------------------------------------------
// --- Configuration for Reporting (emailPageCountReport function) ---
// -------------------------------------------
const REPORT_EMAIL_ADDRESS = "joe@digdefence.com";  // Email address for reports

// Map PO filenames to friendly names for the report
const poPartnerNameMap = {
  "document-PS-amazon": "Amazon",
  "document-PS-chewy": "Chewy",
  "document-PS-dd": "Dig Defence",
  "document-PS-homedepot": "Home Depot",
  "document-PS-lowes": "Lowes",
  "document-PS-menards": "Menards",
  "document-PS-misc": "Misc",
  "document-PS-petco": "Petco",
  "document-PS-sams": "Sams",
  "document-PS-sample": "Sample",
  "document-PS-shein": "Shein",
  "document-PS-temu": "Temu",
  "document-PS-tiktok": "TikTok",
  "document-PS-tsc": "TSC",
  "document-PS-walmart": "Wal-Mart",
  "document-PS-wf": "Wayfair",
  "document-PS-wcs": "WCS"
};

// Map Label filenames to friendly names for the report
const labelPartnerNameMap = {
  "document-PS-amazon-L": "Amazon",
  "document-PS-chewy-L": "Chewy",
  "document-PS-dd-L": "Dig Defence",
  "document-PS-homedepot-L": "Home Depot",
  "document-PS-lowes-L": "Lowes",
  "document-PS-menards-L": "Menards",
  "document-PS-misc-L": "Misc",
  "document-PS-petco-L": "Petco",
  "document-PS-sams-L": "Sams",
  "document-PS-sample-L": "Sample",
  "document-PS-shein-L": "Shein",
  "document-PS-temu-L": "Temu",
  "document-PS-tiktok-L": "TikTok",
  "document-PS-tsc-L": "TSC",
  "document-PS-walmart-L": "Wal-Mart",
  "document-PS-wf-L": "Wayfair",
  "document-PS-wcs-L": "WCS"
};

// =======================================================
// ====== END OF CONFIGURATION ======
// =======================================================

// (Your original functions like renameTradingPartnerFiles, etc., should start below here)



// ======= Trading Partner PDF Renaming =======
function renameTradingPartnerFiles() {
  let totalFiles = 0;
  tradingPartners.forEach(partner => {
    try {
      Logger.log(`Renaming files in folder ${partner.id}`);
      const folder = DriveApp.getFolderById(partner.id);
      const files = folder.getFilesByType(MimeType.PDF);
      let index = 1;
      while (files.hasNext()) {
        const file = files.next();
        file.setName(`${partner.filename}${index > 1 ? `-${index}` : ''}.pdf`);
        index++;
        totalFiles++;
      }
      Logger.log(`Renamed ${index - 1} files in folder ${partner.id}`);
    } catch (e) {
      Logger.log(`Error renaming in folder ${partner.id}: ${e.message}`);
    }
  });
  return `✅ Renamed ${totalFiles} trading partner PDFs`;
}

// ======= Shipping Labels Renaming =======
function renameShippingLabels() {
  let totalFiles = 0;
  shippingLabelPartners.forEach(partner => {
    try {
      Logger.log(`Renaming shipping labels in folder ${partner.id}`);
      const folder = DriveApp.getFolderById(partner.id);
      const files = folder.getFilesByType(MimeType.PDF);
      let index = 1;
      while (files.hasNext()) {
        const file = files.next();
        file.setName(`${partner.filename}${index > 1 ? `-${index}` : ''}.pdf`);
        index++;
        totalFiles++;
      }
      Logger.log(`Renamed ${index - 1} shipping labels in folder ${partner.id}`);
    } catch (e) {
      Logger.log(`Error renaming in folder ${partner.id}: ${e.message}`);
    }
  });
  return `✅ Renamed ${totalFiles} shipping label PDFs`;
}
// ======= Trading Partner PDF Renaming (Thursday) =======
function renameTradingPartnerFilesThurs() {
  let totalFiles = 0;
  tradingPartners.forEach(partner => {
    try {
      Logger.log(`Renaming Thursday files in folder ${partner.id}`);
      const folder = DriveApp.getFolderById(partner.id);
      const files = folder.getFilesByType(MimeType.PDF);
      let index = 1;
      while (files.hasNext()) {
        const file = files.next();
        file.setName(`${partner.filename}${index > 1 ? `-${index}` : ''}-thurs.pdf`);
        index++;
        totalFiles++;
      }
      Logger.log(`Renamed ${index - 1} Thursday files in folder ${partner.id}`);
    } catch (e) {
      Logger.log(`Error renaming Thursday files in folder ${partner.id}: ${e.message}`);
    }
  });
  return `✅ Renamed ${totalFiles} trading partner PDFs with -thurs suffix`;
}

// ======= Shipping Labels Renaming (Thursday) =======
function renameShippingLabelsThurs() {
  let totalFiles = 0;
  shippingLabelPartners.forEach(partner => {
    try {
      Logger.log(`Renaming Thursday shipping labels in folder ${partner.id}`);
      const folder = DriveApp.getFolderById(partner.id);
      const files = folder.getFilesByType(MimeType.PDF);
      let index = 1;
      while (files.hasNext()) {
        const file = files.next();
        // Remove trailing '-L' from original filename
        const baseName = partner.filename.replace(/-L$/, '');
        file.setName(`${baseName}${index > 1 ? `-${index}` : ''}-thurs-L.pdf`);
        index++;
        totalFiles++;
      }
      Logger.log(`Renamed ${index - 1} Thursday shipping labels in folder ${partner.id}`);
    } catch (e) {
      Logger.log(`Error renaming Thursday labels in folder ${partner.id}: ${e.message}`);
    }
  });
  return `✅ Renamed ${totalFiles} shipping label PDFs with -thurs-L suffix`;
}

// ======= Trading Partner PDF Renaming (Sunday) =======
function renameTradingPartnerFilesSun() {
  let totalFiles = 0;
  tradingPartners.forEach(partner => {
    try {
      Logger.log(`Renaming Sunday files in folder ${partner.id}`);
      const folder = DriveApp.getFolderById(partner.id);
      const files = folder.getFilesByType(MimeType.PDF);
      let index = 1;
      while (files.hasNext()) {
        const file = files.next();
        file.setName(`${partner.filename}${index > 1 ? `-${index}` : ''}-sun.pdf`);
        index++;
        totalFiles++;
      }
      Logger.log(`Renamed ${index - 1} Sunday files in folder ${partner.id}`);
    } catch (e) {
      Logger.log(`Error renaming Sunday files in folder ${partner.id}: ${e.message}`);
    }
  });
  return `✅ Renamed ${totalFiles} trading partner PDFs with -sun suffix`;
}

// ======= Shipping Labels Renaming (Sunday) =======
function renameShippingLabelsSun() {
  let totalFiles = 0;
  shippingLabelPartners.forEach(partner => {
    try {
      Logger.log(`Renaming Sunday shipping labels in folder ${partner.id}`);
      const folder = DriveApp.getFolderById(partner.id);
      const files = folder.getFilesByType(MimeType.PDF);
      let index = 1;
      while (files.hasNext()) {
        const file = files.next();
        // Remove trailing '-L' from original filename
        const baseName = partner.filename.replace(/-L$/, '');
        file.setName(`${baseName}${index > 1 ? `-${index}` : ''}-sun-L.pdf`);
        index++;
        totalFiles++;
      }
      Logger.log(`Renamed ${index - 1} Sunday shipping labels in folder ${partner.id}`);
    } catch (e) {
      Logger.log(`Error renaming Sunday labels in folder ${partner.id}: ${e.message}`);
    }
  });
  return `✅ Renamed ${totalFiles} shipping label PDFs with -sun-L suffix`;
}








// ======= Shipping Manifests Renaming =======
function renameShippingManifestPDFs() {
  let totalFiles = 0;
  shippingManifestPartners.forEach(partner => {
    try {
      Logger.log(`Renaming shipping manifests in folder ${partner.id}`);
      const folder = DriveApp.getFolderById(partner.id);
      const files = folder.getFilesByType(MimeType.PDF);
      let index = 1;
      while (files.hasNext()) {
        const file = files.next();
        file.setName(`${partner.filename}${index > 1 ? `-${index}` : ''}.pdf`);
        index++;
        totalFiles++;
      }
      Logger.log(`Renamed ${index - 1} shipping manifests in folder ${partner.id}`);
    } catch (e) {
      Logger.log(`Error renaming in folder ${partner.id}: ${e.message}`);
    }
  });
  return `✅ Renamed ${totalFiles} shipping manifest PDFs`;
}

// ======= Rename File Ext =======
function renameFileToPDF() {
  // Collect all relevant folder IDs
  const allFolderIds = [
    ...tradingPartners.map(p => p.id),
    ...shippingLabelPartners.map(p => p.id),
    ...shippingManifestPartners.map(p => p.id),
    DDPOS_FOLDER_ID,
    TRADING_PARTNER_DESTINATION_ID,
    SHIPPING_LABEL_DESTINATION_ID,
    SHIPPING_MANIFEST_DESTINATION_ID
  ];

  let totalRenamed = 0;

  allFolderIds.forEach(folderId => {
    try {
      const folder = DriveApp.getFolderById(folderId);
      const files = folder.getFiles();

      while (files.hasNext()) {
        const file = files.next();
        const name = file.getName();

        // Skip folders and files that already have an extension
        if (!name.includes('.')) {
          const newName = `${name}.pdf`;
          file.setName(newName);
          totalRenamed++;
          Logger.log(`Renamed "${name}" to "${newName}" in folder ${folderId}`);
        }
      }
    } catch (e) {
      Logger.log(`Error processing folder ${folderId}: ${e.message}`);
    }
  });

  return `✅ Renamed ${totalRenamed} file(s) to add .pdf extension`;
}

// ======= Copy Trading Partner PDFs =======
function copyTradingPartnerPDFs() {
  let totalFiles = 0;
  try {
    Logger.log(`Copying to destination folder ${TRADING_PARTNER_DESTINATION_ID}`);
    const destFolder = DriveApp.getFolderById(TRADING_PARTNER_DESTINATION_ID);
    tradingPartners.forEach(partner => {
      try {
        Logger.log(`Copying from folder ${partner.id}`);
        const sourceFolder = DriveApp.getFolderById(partner.id);
        const files = sourceFolder.getFilesByType(MimeType.PDF);
        let index = 1;
        while (files.hasNext()) {
          const file = files.next();
          file.makeCopy(`${file.getName()}${index > 1 ? `-${index}` : ''}`, destFolder);
          index++;
          totalFiles++;
        }
        Logger.log(`Copied ${index - 1} files from folder ${partner.id}`);
      } catch (e) {
        Logger.log(`Error copying from folder ${partner.id}: ${e.message}`);
      }
    });
    return `✅ Copied ${totalFiles} trading partner PDFs to destination folder`;
  } catch (e) {
    Logger.log(`Error accessing destination folder ${TRADING_PARTNER_DESTINATION_ID}: ${e.message}`);
    return `⚠️ Failed to copy trading partner PDFs: ${e.message}`;
  }
}

// ======= Copy Shipping Label PDFs =======
function copyShippingLabelPDFs() {
  let totalFiles = 0;
  try {
    Logger.log(`Copying to destination folder ${SHIPPING_LABEL_DESTINATION_ID}`);
    const destFolder = DriveApp.getFolderById(SHIPPING_LABEL_DESTINATION_ID);
    shippingLabelPartners.forEach(partner => {
      try {
        Logger.log(`Copying from folder ${partner.id}`);
        const sourceFolder = DriveApp.getFolderById(partner.id);
        const files = sourceFolder.getFilesByType(MimeType.PDF);
        let index = 1;
        while (files.hasNext()) {
          const file = files.next();
          file.makeCopy(`${file.getName()}${index > 1 ? `-${index}` : ''}`, destFolder);
          index++;
          totalFiles++;
        }
        Logger.log(`Copied ${index - 1} files from folder ${partner.id}`);
      } catch (e) {
        Logger.log(`Error copying from folder ${partner.id}: ${e.message}`);
      }
    });
    return `✅ Copied ${totalFiles} shipping label PDFs to destination folder`;
  } catch (e) {
    Logger.log(`Error accessing destination folder ${SHIPPING_LABEL_DESTINATION_ID}: ${e.message}`);
    return `⚠️ Failed to copy shipping label PDFs: ${e.message}`;
  }
}

// ======= Copy Shipping Manifest PDFs =======
function copyShippingManifestPDFs() {
  let totalFiles = 0;
  try {
    Logger.log(`Copying to destination folder ${SHIPPING_MANIFEST_DESTINATION_ID}`);
    const destFolder = DriveApp.getFolderById(SHIPPING_MANIFEST_DESTINATION_ID);
    shippingManifestPartners.forEach(partner => {
      try {
        Logger.log(`Copying from folder ${partner.id}`);
        const sourceFolder = DriveApp.getFolderById(partner.id);
        const files = sourceFolder.getFilesByType(MimeType.PDF);
        let index = 1;
        while (files.hasNext()) {
          const file = files.next();
          file.makeCopy(`${file.getName()}${index > 1 ? `-${index}` : ''}`, destFolder);
          index++;
          totalFiles++;
        }
        Logger.log(`Copied ${index - 1} files from folder ${partner.id}`);
      } catch (e) {
        Logger.log(`Error copying from folder ${partner.id}: ${e.message}`);
      }
    });
    return `✅ Copied ${totalFiles} shipping manifest PDFs to destination folder`;
  } catch (e) {
    Logger.log(`Error accessing destination folder ${SHIPPING_MANIFEST_DESTINATION_ID}: ${e.message}`);
    return `⚠️ Failed to copy shipping manifest PDFs: ${e.message}`;
  }
}

// ======= Moving Shipping Docs =======
function moveShippingDocuments() {
  try {
    const SOURCE_FOLDERS = [
      "1KKU7TUn3NrUSGVqKd-lZIpEMWwGQxOOY", // All Combined Packing Slips Folder
      "1YVqcBeCd3aasg-cSxSBLzxqb85sUZcuN"  // All Combined Labels Folder
    ];
    const DESTINATION_FOLDER_ID = "148LZNOxM1T5dojvNj5Zi7Y4zbsmZUDwK";
    const destination = DriveApp.getFolderById(DESTINATION_FOLDER_ID);
    let totalCopied = 0;

    SOURCE_FOLDERS.forEach(folderId => {
      const folder = DriveApp.getFolderById(folderId);
      const files = folder.getFilesByType(MimeType.PDF);

      while (files.hasNext()) {
        const file = files.next();
        file.makeCopy(file.getName(), destination);
        totalCopied++;
      }
    });

    Logger.log(`Copied ${totalCopied} PDF(s) to destination folder`);
    return `✅ ${totalCopied} PDF(s) copied to Shipping Documents folder`;
  } catch (e) {
    Logger.log(`Error in prepareShippingDocuments: ${e.message}`);
    return `⚠️ Failed to prepare shipping documents: ${e.message}`;
  }
}

// ======= Purge All PDFs =======
function purgeAllPDFs() {
  const allFolderIds = new Set([
    ...tradingPartners.map(p => p.id),
    ...shippingLabelPartners.map(p => p.id),
    ...shippingManifestPartners.map(p => p.id),
    DDPOS_FOLDER_ID,              // Final PO PDF Folder
    TRADING_PARTNER_DESTINATION_ID,   // All Combined Packing Slip Folder
    SHIPPING_LABEL_DESTINATION_ID,    // All Combined Shipping Label Folder
    SHIPPING_MANIFEST_DESTINATION_ID  // All Combined Manifests Folder
  ]);

  let totalDeleted = 0;

  allFolderIds.forEach(id => {
    if (id && !id.match(/^(YOUR_|DDPOS_)/)) {
      try {
        const folder = DriveApp.getFolderById(id);
        const files = folder.getFiles();
        let count = 0;
        while (files.hasNext()) {
          files.next().setTrashed(true);
          count++;
        }
        totalDeleted += count;
      } catch (e) {
        Logger.log(`Skipped folder ${id}: ${e.message}`);
      }
    } else {
      Logger.log(`Skipped invalid or placeholder folder ID: ${id}`);
    }
  });

  return `✅ Purged ${totalDeleted} file(s) from all PDF folders`;
}

// ======= Purge Daily PDFs =======
function purgeDailyShippingDocs() {
  try {
    const FOLDER_ID = "148LZNOxM1T5dojvNj5Zi7Y4zbsmZUDwK";
    const folder = DriveApp.getFolderById(FOLDER_ID);
    const files = folder.getFiles(); // all files, not just PDFs
    let totalDeleted = 0;

    while (files.hasNext()) {
      const file = files.next();
      Logger.log(`Deleting: ${file.getName()}`);
      file.setTrashed(true);
      totalDeleted++;
    }

    Logger.log(`Purged ${totalDeleted} file(s) from Daily Shipping Docs folder`);
    return `✅ Purged ${totalDeleted} file(s) from Daily Shipping Docs folder`;
  } catch (e) {
    Logger.log(`Error in purgeDailyShippingDocs: ${e.message}`);
    return `⚠️ Failed to purge Daily Shipping Docs: ${e.message}`;
  }
}



// ======= Menards Shipping Extraction Script =======
// ======= Menards Shipping Extraction Script =======
// ======= Menards Shipping Extraction Script =======
// ======= Menards Shipping Extraction Script =======



/**
 * Configuration settings for the script.
 * @const
 */
const CONFIG = {
  FOLDER_ID: '1NH19Eiq_Kc5uAEmdijSkuNdYIJYClHCU',
  SHEET_ID: '18S8eTH-OLVJwJSS7fZo6UD6Ut2TAtSSMDCFtHxDZahY',
  SHEET_NAME: 'Sheet1',
  SKU_MAP: {
    '2-4':   { internalSKU: 'DD2083204',  weight: 8.5 },
    '2-10':  { internalSKU: 'DD2083210',  weight: 20 },
    '2-25':  { internalSKU: 'DD2083225',  weight: 49 },
    '3-4':   { internalSKU: 'DD3103204',  weight: 8.8 },
    '3-10':  { internalSKU: 'DD3103210',  weight: 20.4 },
    '3-25':  { internalSKU: 'DD3103225',  weight: 49.8 },
    'XL-2':  { internalSKU: 'DDXL152402', weight: 7.6 },
    'XL-5':  { internalSKU: 'DDXL152405', weight: 18 },
    'XL-15': { internalSKU: 'DDXL152415', weight: 52.5 },
  },
};

/**
 * Main function to process Menards PDFs from a Drive folder and log data to a Sheet.
 */
function extractMenardsShippingData() {
  const sheet = SpreadsheetApp.openById(CONFIG.SHEET_ID).getSheetByName(CONFIG.SHEET_NAME);
  sheet.clear();
  const headers = ['PKG_PACKAGE_ID', 'SHPTO_NAME', 'SHPTO_ADDRESS_1', 'SHPTO_ADDRESS_2', 'SHPTO_ADDRESS_3','SHPTO_CITY', 'SHPTO_STATE_PROV', 'SHPTO_POSTAL_CODE', 'SHPTO_COUNTRY_ID', 'PKG_TELEPHONE','PKG_SERVICE_TYPE', 'PKG_WEIGHT_ACTUAL', 'PKG_CUSTOM1', 'PKG_CUSTOM2', 'PKG_CUSTOM3','PKG_CUSTOM4', 'PKG_CUSTOM5', 'SHPTO_RESIDENTIAL', 'UOL_SOURCE', 'SHPTO_ATTN_LINE','SHPTO_COMPANY', 'MERCHANT_ID'];
  sheet.appendRow(headers);
  const folder = DriveApp.getFolderById(CONFIG.FOLDER_ID);
  const files = folder.getFilesByType(MimeType.PDF);
  let processedCount = 0;
  while (files.hasNext()) {
    const file = files.next();
    const poNumber = file.getName().replace(/\.pdf$/i, '');
    let ocrFileId = null;
    try {
      const text = getOcrText_(file);
      ocrFileId = text.tempDocId;
      const shipToData = parseShipToBlock_(text.content);
      const lineItems = parseLineItems_(text.content);
      if (lineItems.length === 0) throw new Error('No line items could be parsed from the PDF.');
      // --- In your extractMenardsShippingData function ---

     for (const item of lineItems) {
        
        // --- THIS IS THE LINE TO CHANGE ---
        const rowData = [
          poNumber, shipToData.name, shipToData.address, '', '', shipToData.city, shipToData.state, shipToData.postal, 'US', shipToData.phone,
          'STANDARD', item.weight, item.internalSku, poNumber, shipToData.customerName, shipToData.storeNum, item.quantity, 'N', '', shipToData.name, shipToData.name, 'menards'
        ];
        // ----------------------------------

        sheet.appendRow(rowData);
      }
      processedCount++;
    } catch (e) {
      Logger.log(`Error processing ${file.getName()}: ${e.message}`);
      sheet.appendRow([poNumber, `ERROR: ${e.message}`]);
    } finally {
      if (ocrFileId) Drive.Files.remove(ocrFileId);
    }
  }
  Logger.log(`✅ Extracted shipping info from ${processedCount} PDF(s).`);
}
/**
 * Extracts text from a PDF file using OCR, with a retry mechanism for API errors.
 * @param {GoogleAppsScript.Drive.File} file The PDF file to process.
 * @return {{content: string, tempDocId: string}} An object with the extracted text and temp file ID.
 * @private
 */
function getOcrText_(file) {
  const resource = { title: `temp-ocr-${file.getName()}`, mimeType: MimeType.GOOGLE_DOCS };
  let ocrFile;

  // Try the API call up to 3 times.
  for (let i = 0; i < 3; i++) {
    try {
      ocrFile = Drive.Files.create(resource, file.getBlob(), { ocr: true });
      // If the call is successful, break out of the retry loop.
      break;
    } catch (e) {
      Logger.log(`API call failed on attempt ${i + 1}. Retrying in 2 seconds. Error: ${e.message}`);
      // If this was the last attempt, give up and throw the error.
      if (i === 2) {
        throw e;
      }
      // Wait for 2 seconds before the next attempt.
      Utilities.sleep(2000);
    }
  }

  const doc = DocumentApp.openById(ocrFile.id);
  const text = doc.getBody().getText();
  return { content: text, tempDocId: ocrFile.id };
}

/**
 * Parses the "Ship To" block from the OCR text to extract address details.
 * @param {string} text The full text content from the PDF.
 * @return {{name: string, address: string, city: string, state: string, postal: string, phone: string}} The parsed address information.
 * @private
 */
/**
 * Parses the OCR text to extract shipping, customer, and store info.
 * @param {string} text The full OCR text from the PDF.
 * @return {object} An object containing the parsed data.
 */
function parseShipToBlock_(text) {
  
  // 1. Initialize the data object with all the new fields
  const data = { 
    name: '', 
    address: '', 
    city: '', 
    state: '', 
    postal: '', 
    phone: '', 
    storeNum: '', 
    customerName: '' 
  };

  // 2. --- Find the Store Number ---
  // Looks for "Bill To:" followed by a number
  const storeMatch = text.match(/Bill To:\s*(\d+)/i);
  if (storeMatch && storeMatch[1]) {
    data.storeNum = storeMatch[1].trim(); // e.g., "3268"
  }

  // 3. --- Find the Customer Name ---
  // Looks for "Guest Information:" followed by a name on the next line
  const guestMatch = text.match(/Guest Information:\s*\n\s*([^\n]+)/i);
  if (guestMatch && guestMatch[1]) {
    data.customerName = guestMatch[1].trim(); // e.g., "Dunham, Carl"
  }

  // 4. --- Original "Ship To" Block Parsing Logic ---
  // (This is your original code, it remains unchanged)
  const match = text.match(/Ship To:\s*([\s\S]*?)(?=Guest Information:|Bill To:)/i);

  if (match && match[1]) {
    const lines = match[1].split('\n').map(line => line.trim()).filter(Boolean);
    const cszIndex = lines.findIndex(line => /,\s*[A-Z]{2}\s*\d{5}/.test(line));
    const phoneIndex = lines.findIndex(line => /Phone:/.test(line));
    const nameLine = lines.find((line, index) => {
      return index !== cszIndex && index !== phoneIndex && /^[A-Z\s]+$/i.test(line) && !/^\d{4}$/.test(line);
    });
    data.name = nameLine || '';
    if (cszIndex !== -1) {
      const cszMatch = lines[cszIndex].match(/(.+?),\s*([A-Z]{2})\s*(\d{5}(?:-\d{4})?)/);
      if (cszMatch) {
        let potentialCityAndAddress = cszMatch[1].trim();
        data.state = cszMatch[2].trim();
        data.postal = cszMatch[3].trim();
        if (/\d/.test(potentialCityAndAddress) && data.name) {
          const parts = potentialCityAndAddress.split(new RegExp(`\\s+${data.name}$`, 'i'));
          data.address = parts[0].trim();
          data.city = data.name;
        } else {
          data.city = potentialCityAndAddress;
        }
      }
    }
    if (phoneIndex !== -1) {
      const phoneMatch = lines[phoneIndex].match(/Phone:\s*([\d-]+)/i);
      if(phoneMatch) data.phone = phoneMatch[1].trim();
    }
    if (!data.address) {
      const addressLine = lines.find(line => /\d/.test(line) && !line.includes(data.postal) && !/Phone:/.test(line) && !/^\d{4}$/.test(line));
      if(addressLine) data.address = addressLine;
    }
  }
  
  // 5. Return the complete data object
  return data;
}
/**
 * Parses all line items from the OCR text.
 * @param {string} text The full text content from the PDF.
 *To * @return {Array<Object>} A list of item objects, each with vendorSku, internalSku, quantity, and weight.
 * @private
 */
function parseLineItems_(text) {
  const items = [];
  // This final regex is built based on the actual OCR output from the log.
  const itemRegex = /1002485\s+DIGDE001 Special Order\s+(\d+)\s+[\d,.]+\s+Package\s+[\d,.]+\s+Vendor Part #:\s*([\w-]+)/g;
  let match;

  while ((match = itemRegex.exec(text)) !== null) {
    // NOTE: The capture group order has changed.
    // match[1] is now the Quantity.
    // match[2] is now the Vendor SKU.
    const quantity = match[1].trim();
    const vendorSku = match[2].trim();
    const mappedSku = CONFIG.SKU_MAP[vendorSku] || { internalSKU: `NOT_FOUND: ${vendorSku}`, weight: '' };

    items.push({
      vendorSku: vendorSku,
      quantity: quantity,
      internalSku: mappedSku.internalSKU,
      weight: mappedSku.weight
    });
  }
  return items;
}

// ======= WCS Shipping Extraction Script =======
// ======= WCS Shipping Extraction Script =======
// ======= WCS Shipping Extraction Script =======
// ======= WCS Shipping Extraction Script =======
// ======= WCS Shipping Extraction Script =======


/**
 * Configuration settings for the WCS script.
 * @const
 */
const CONFIG_WCS = {
  FOLDER_ID: '1yzEmFqG-T50m1sao1-f0rzGzH5sXGwc6',
  SHEET_ID: '18S8eTH-OLVJwJSS7fZo6UD6Ut2TAtSSMDCFtHxDZahY',
  SHEET_NAME: 'Sheet1',
  SKU_MAP: {
    'DDAC-Tool-C': { internalSKU: 'DDAC-TOOL',  weight: 19.9 },
  },
};

/**
 * Main function to process WCS PDFs from a Drive folder and log data to a Sheet.
 */
function extractWCSData() {
  const sheet = SpreadsheetApp.openById(CONFIG_WCS.SHEET_ID).getSheetByName(CONFIG_WCS.SHEET_NAME) || 
                SpreadsheetApp.openById(CONFIG_WCS.SHEET_ID).insertSheet(CONFIG_WCS.SHEET_NAME);
  sheet.clear();

  const headers = [
    'PKG_PACKAGE_ID', 'SHPTO_NAME', 'SHPTO_ADDRESS_1', 'SHPTO_ADDRESS_2', 'SHPTO_ADDRESS_3',
    'SHPTO_CITY', 'SHPTO_STATE_PROV', 'SHPTO_POSTAL_CODE', 'SHPTO_COUNTRY_ID', 'PKG_TELEPHONE',
    'PKG_SERVICE_TYPE', 'PKG_WEIGHT_ACTUAL', 'PKG_CUSTOM1', 'PKG_CUSTOM2', 'PKG_CUSTOM3',
    'PKG_CUSTOM4', 'PKG_CUSTOM5', 'SHPTO_RESIDENTIAL', 'UOL_SOURCE', 'SHPTO_ATTN_LINE',
    'SHPTO_COMPANY', 'MERCHANT_ID',
  ];
  sheet.appendRow(headers);

  // This helper function is assumed to exist from the previous Menards script
  // If it doesn't, you would need to include it in your script file.
  if (typeof getOcrText_ === 'undefined') {
    throw new Error('The helper function getOcrText_ is missing from your script file.');
  }

  const folder = DriveApp.getFolderById(CONFIG_WCS.FOLDER_ID);
  const files = folder.getFilesByType(MimeType.PDF);
  let processedCount = 0;

  while (files.hasNext()) {
    const file = files.next();
    let ocrFileId = null;

    try {
      const text = getOcrText_(file); 
      ocrFileId = text.tempDocId;

      const poNumberMatch = text.content.match(/PO #\s*(\w+)/);
      const poNumber = poNumberMatch ? poNumberMatch[1] : `NO_PO_FOUND_IN_${file.getName()}`;
      
      const shipToData = parseWCSShipToBlock_(text.content);
      const lineItems = parseWCSLineItems_(text.content);
      
      if (lineItems.length === 0) {
        throw new Error('No line items could be parsed.');
      }

      for (const item of lineItems) {
        const rowData = [
          poNumber, shipToData.name, shipToData.address1, shipToData.address2, '', 
          shipToData.city, shipToData.state, shipToData.postal, 'US', shipToData.phone,
          'STANDARD', item.weight, item.internalSku, poNumber, '', poNumber, item.quantity, 
          'Y', '', shipToData.name, shipToData.company, 'wcs',
        ];
        sheet.appendRow(rowData);
      }
      processedCount++;

    } catch (e) {
      Logger.log(`Error processing ${file.getName()}: ${e.message}`);
      sheet.appendRow([file.getName(), `ERROR: ${e.message}`]);
    } finally {
      if (ocrFileId) {
        Drive.Files.remove(ocrFileId);
      }
    }
  }
  Logger.log(`✅ Extracted shipping info from ${processedCount} WCS PDF(s).`);
}


/**
 * Parses the WCS "Ship To" block from OCR text by finding the block between "Prepared By" and "Memo".
 * @param {string} text The full text content from the PDF.
 * @return {Object} The parsed address information.
 * @private
 */
function parseWCSShipToBlock_(text) {
  const data = { name: '', company: '', address1: '', address2: '', city: '', state: '', postal: '', phone: '' };
  // New, more reliable regex to find the correct address block.
  const shipToMatch = text.match(/Prepared By:[\s\S]*?\n([\s\S]*?)(?=Memo|Customer Phone|Item Code)/);
  
  if (shipToMatch && shipToMatch[1]) {
    const lines = shipToMatch[1].split('\n').map(l => l.trim()).filter(Boolean);
    
    const phoneMatch = text.match(/Customer Phone\s*([\d\(\)\s-]+)/);
    if(phoneMatch) data.phone = phoneMatch[1].trim();

    const cszLine = lines.find(l => /[A-Z]{2}\s+\d{5}/.test(l));
    if (cszLine) {
      const cszMatch = cszLine.match(/(.+?)\s+([A-Z]{2})\s+(\d{5}(?:-\d{4})?)/);
      if (cszMatch) {
          data.city = cszMatch[1].trim();
          data.state = cszMatch[2].trim();
          data.postal = cszMatch[3].trim();
      }
    }
    
    // Process remaining lines for name, company, and address
    const addressLines = lines.filter(l => l !== cszLine && l !== 'United States');
    data.name = addressLines.shift() || '';
    
    // Check if the next line looks like a company name (doesn't start with a number or contain address keywords)
    if (addressLines.length > 0 && !/^\d/.test(addressLines[0]) && !/rd|st|ln|blvd|rd/i.test(addressLines[0])) {
      data.company = addressLines.shift() || '';
    }

    data.address1 = addressLines.shift() || '';
    data.address2 = addressLines.join(' '); 
  }
  return data;
}

/**
 * Parses all WCS line items from the OCR text using a columnar approach.
 * @param {string} text The full text content from the PDF.
 * @return {Array<Object>} A list of item objects.
 * @private
 */
function parseWCSLineItems_(text) {
  const items = [];
  const itemCodeBlockMatch = text.match(/Item Code\s*([\s\S]*?)\s*Quantity/);
  const quantityBlockMatch = text.match(/Quantity\s*([\s\S]*?)\s*Description/);

  if (itemCodeBlockMatch && quantityBlockMatch) {
    const itemCodes = itemCodeBlockMatch[1].match(/(DDAC-Tool-C|Shipping-PO Drop)/g) || [];
    const quantities = quantityBlockMatch[1].split('\n').map(l => l.trim()).filter(Boolean);

    if (itemCodes.length > 0 && itemCodes.length === quantities.length) {
      for (let i = 0; i < itemCodes.length; i++) {
        const itemCode = itemCodes[i];
        const quantity = quantities[i];
        
        if (itemCode === 'Shipping-PO Drop') continue;
        
        const mappedSku = CONFIG_WCS.SKU_MAP[itemCode] || { internalSKU: `NOT_FOUND: ${itemCode}`, weight: '' };

        items.push({
          itemCode: itemCode,
          quantity: quantity,
          internalSku: mappedSku.internalSKU,
          weight: mappedSku.weight
        });
      }
    }
  }
  return items;
}

// =======================================================
// ====== REPORTING FUNCTION (Native Parsing - BOLD TITLES) ======
// =======================================================

/**
 * Scans all partner folders (both POs and Labels), calculates totals using
 * native Apps Script PDF parsing, and emails a report with bold titles.
 */
function emailPageCountReport() {
  Logger.log('Starting Page & Package Count Report function (Native Parsing)...');
  
  // --- Configuration Checks ---
  // Ensure required constants are defined
  if (typeof REPORT_EMAIL_ADDRESS === 'undefined' || !REPORT_EMAIL_ADDRESS || REPORT_EMAIL_ADDRESS === 'your-email@example.com') {
      Logger.log('ERROR: REPORT_EMAIL_ADDRESS is not defined or is placeholder.'); return; }
  if (typeof poPartnerNameMap === 'undefined' || typeof labelPartnerNameMap === 'undefined' ) {
      Logger.log('ERROR: poPartnerNameMap or labelPartnerNameMap is not defined.'); return; }
   if (typeof tradingPartners === 'undefined' || typeof shippingLabelPartners === 'undefined' ) {
      Logger.log('ERROR: tradingPartners or shippingLabelPartners array is not defined.'); return; }
  // --- End Checks ---

  let poReportData = {};
  let packageReportData = {};
  let grandTotalPageCount = 0;
  let grandTotalPackageCount = 0;

  // --- Helper function to get page count ---
// --- Helper function to get page count ---
  function getNativePageCount(file) {
    let filePageCount = 0;
    try {
      const blob = file.getBlob();
      // Use 'ISO-8859-1' to read the binary data as text without corrupting it
      const content = blob.getDataAsString('ISO-8859-1'); 

      // --- NEW STRATEGY ---
      // Instead of looking for "/Pages /Count [number]", we will
      // count every instance of "/Type /Page" (which defines a single page).
      // This is far more reliable across different PDF structures.
      const pageRegex = /\/Type\s*\/Page\b/g;
      const matches = content.match(pageRegex);

      if (matches && matches.length > 0) {
        filePageCount = matches.length;
      } else {
        // --- FALLBACK STRATEGY ---
        // If for some reason we find 0 /Page tags, we'll try the old
        // method one last time. This is just a safety net.
        Logger.log(`Warning: Could not find any /Type /Page definitions in: ${file.getName()}. Trying /Pages /Count method...`);
        
        const countRegex = /\/Type\s*\/Pages[\s\S]*?\/Count\s+(\d+)/;
        const countMatch = content.match(countRegex);
        
        if (countMatch && countMatch[1]) {
          filePageCount = parseInt(countMatch[1], 10);
          Logger.log(`--> Fallback succeeded. Found /Pages /Count of: ${filePageCount}`);
        } else {
          Logger.log(`--> ERROR: All parsing methods failed for ${file.getName()}. Returning 0.`);
        }
      }
    } catch (e) {
      Logger.log(`Error natively processing file ${file.getName()}: ${e.message}`);
      if (e.message.includes("exceeded maximum execution time")) {
         Logger.log(`--> File ${file.getName()} might be too large for native text extraction.`);
      }
    }
    return filePageCount;
  }
  // --- End Helper ---
  // --- End Helper ---

  try {
    // Initialize report data
    for (const key in poPartnerNameMap) {
      poReportData[poPartnerNameMap[key]] = 0;
    }
    for (const key in labelPartnerNameMap) {
      packageReportData[labelPartnerNameMap[key]] = 0;
    }

    // === Step 1: Loop through all ORIGINAL PO folders ===
    Logger.log('Scanning ORIGINAL PO folders...');
    for (const partner of tradingPartners) {
      const partnerName = poPartnerNameMap[partner.filename];
      if (!partnerName) {
        Logger.log(`Skipping unknown PO partner: ${partner.filename}`);
        continue;
      }

      try { 
        const sourceFolder = DriveApp.getFolderById(partner.id);
        const files = sourceFolder.getFilesByType(MimeType.PDF);
        let partnerTotalPages = 0;

        while (files.hasNext()) {
          const file = files.next();
          // Skip any leftover -SOS files in PO folders 
          if (!file.getName().toUpperCase().includes('-SOS')) {
             partnerTotalPages += getNativePageCount(file); 
          }
        } 
        
        poReportData[partnerName] += partnerTotalPages; 
        grandTotalPageCount += partnerTotalPages;
        Logger.log(`- ${partnerName} Original PO Pages: ${partnerTotalPages}`);
      } catch (folderError) {
         Logger.log(`Error accessing original PO folder for ${partnerName} (ID: ${partner.id}): ${folderError.message}`);
      }
    } 
    Logger.log('Original PO scanning complete.');

    // === Step 1.5: Loop through the DDPOS folder (split POs) ===
    Logger.log('Scanning DDPOS folder for split POs...');
    // Check if the variable is defined and not a placeholder
    if (typeof DEST_FOLDER_URL_FOR_POS !== 'undefined' && DEST_FOLDER_URL_FOR_POS && DEST_FOLDER_URL_FOR_POS !== 'YOUR_PO_DESTINATION_FOLDER_URL') {
        try {
            const ddposFolderId = DEST_FOLDER_URL_FOR_POS.split('/').pop(); 
            const ddposFolder = DriveApp.getFolderById(ddposFolderId);
            const ddposFiles = ddposFolder.getFilesByType(MimeType.PDF);
            let ddposTotalPages = 0;

            while (ddposFiles.hasNext()) {
                const file = ddposFiles.next();
                const fileName = file.getName();
                if (fileName.toUpperCase().includes('-SOS')) continue; 
                
                let partnerFound = false;
                for (const partnerFilename in poPartnerNameMap) {
                    if (fileName.startsWith(partnerFilename)) { 
                        const partnerName = poPartnerNameMap[partnerFilename];
                        const filePageCount = getNativePageCount(file);
                        
                        if (poReportData.hasOwnProperty(partnerName)) {
                           poReportData[partnerName] += filePageCount; 
                           grandTotalPageCount += filePageCount; 
                           ddposTotalPages += filePageCount;
                           Logger.log(`- Found split PO for ${partnerName}: ${fileName} (${filePageCount} pages)`);
                           partnerFound = true;
                           break; 
                        } else {
                           Logger.log(`- Matched file ${fileName} to partner ${partnerName}, but partner not in report map.`);
                        }
                    }
                }
                if (!partnerFound) {
                    Logger.log(`- Found file in DDPOS, but couldn't match to partner: ${fileName}`);
                }
            }
             Logger.log(`DDPOS scanning complete. Found ${ddposTotalPages} pages in split POs.`);
        } catch (e) {
            Logger.log(`Error scanning DDPOS folder (URL: ${DEST_FOLDER_URL_FOR_POS}): ${e.message}`);
        }
    } else {
       Logger.log('Skipping DDPOS scan: DEST_FOLDER_URL_FOR_POS variable is not configured or is placeholder.');
    }


    // === Step 2: Loop through all Label folders ===
    Logger.log('Scanning Label folders...');
     for (const partner of shippingLabelPartners) {
      const partnerName = labelPartnerNameMap[partner.filename];
      if (!partnerName) {
        Logger.log(`Skipping unknown Label partner: ${partner.filename}`);
        continue;
      }
      try { 
        const sourceFolder = DriveApp.getFolderById(partner.id);
        const files = sourceFolder.getFilesByType(MimeType.PDF);
        let partnerTotalPages = 0;
        
        while (files.hasNext()) {
          const file = files.next();
          partnerTotalPages += getNativePageCount(file); 
        } 
        
        packageReportData[partnerName] = partnerTotalPages; 
        grandTotalPackageCount += partnerTotalPages;
        Logger.log(`- ${partnerName} Label Pages: ${partnerTotalPages}`);
      } catch (folderError) {
          Logger.log(`Error accessing Label folder for ${partnerName} (ID: ${partner.id}): ${folderError.message}`);
      }
    } 
    Logger.log(`Label scanning complete. Total Label Pages: ${grandTotalPackageCount}`);

    // === Step 3: Build and Send the Email (as HTML) ===
    Logger.log('All folders scanned. Building and sending HTML email report...');
    
    const today = new Date().toLocaleDateString('en-US');
    const emailSubject = `Daily PO Pack Count - ${today}`;

    // Build the email body as an HTML string
    // Using <pre> tags helps preserve spacing similar to the plain text version
    const emailBodyHtml = `
      
      <b>OVERALL TOTALS</b><br>
      POs: ${grandTotalPageCount}<br>
      Packs: ${grandTotalPackageCount}<br>
      <br>
      <b>OUTLET PO COUNT</b><br>
      Amazon: ${poReportData['Amazon'] || 0}<br>
      Chewy: ${poReportData['Chewy'] || 0}<br>
      Dig Defence: ${poReportData['Dig Defence'] || 0}<br>
      Home Depot: ${poReportData['Home Depot'] || 0}<br>
      Lowes: ${poReportData['Lowes'] || 0}<br>
      Menards: ${poReportData['Menards'] || 0}<br>
      Misc: ${poReportData['Misc'] || 0}<br>
      Petco: ${poReportData['Petco'] || 0}<br>
      Sams: ${poReportData['Sams'] || 0}<br>
      Shein: ${poReportData['Shein'] || 0}<br>
      Temu: ${poReportData['Temu'] || 0}<br>
      TSC: ${poReportData['TSC'] || 0}<br>
      Wal-Mart: ${poReportData['Wal-Mart'] || 0}<br>
      WCS: ${poReportData['WCS'] || 0}<br>
      Wayfair: ${poReportData['Wayfair'] || 0}<br>
      <br>
      <b>OUTLET PACKAGE COUNT</b><br>
      Amazon: ${packageReportData['Amazon'] || 0}<br>
      Chewy: ${packageReportData['Chewy'] || 0}<br>
      Dig Defence: ${packageReportData['Dig Defence'] || 0}<br>
      Home Depot: ${packageReportData['Home Depot'] || 0}<br>
      Lowes: ${packageReportData['Lowes'] || 0}<br>
      Menards: ${packageReportData['Menards'] || 0}<br>
      Misc: ${packageReportData['Misc'] || 0}<br>
      Petco: ${packageReportData['Petco'] || 0}<br>
      Sams: ${packageReportData['Sams'] || 0}<br>
      Shein: ${packageReportData['Shein'] || 0}<br>
      Temu: ${packageReportData['Temu'] || 0}<br>
      TSC: ${packageReportData['TSC'] || 0}<br>
      Wal-Mart: ${packageReportData['Wal-Mart'] || 0}<br>
      WCS: ${packageReportData['WCS'] || 0}<br>
      Wayfair: ${packageReportData['Wayfair'] || 0}<br>
    `;

    // Send the email using the 'htmlBody' option
    MailApp.sendEmail({
      to: REPORT_EMAIL_ADDRESS,
      subject: emailSubject,
      htmlBody: emailBodyHtml // Use htmlBody instead of body
    });

    Logger.log(`Report successfully sent to ${REPORT_EMAIL_ADDRESS}`);

  } catch (e) {
    Logger.log(`An error occurred in emailPageCountReport: ${e.toString()}`);
    try {
       // Send error email as plain text for simplicity
       MailApp.sendEmail({
        to: REPORT_EMAIL_ADDRESS,
        subject: `PDF Report FAILED - ${new Date().toLocaleDateString('en-US')}`,
        body: `The automated PDF report failed to run.\n\nError: ${e.toString()}`
      });
    } catch (mailError) {
      Logger.log(`Failed to send error email: ${mailError.toString()}`);
    }
  }
}

// =======================================================
// =============== Manifest Merging Function =============
// =======================================================

// =======================================================
// ====== PDF MERGING FUNCTION & HELPERS (iLovePDF ONLY) ======
// =======================================================

/**
 * FUNCTION: Merge PDFs using iLovePDF API
 * Merges all PDFs from a source folder into one file in a destination folder.
 */
function mergeManifests() {
  // --- Define Source, Destination, and Output Name ---
  const sourceFolderUrl = 'https://drive.google.com/drive/folders/11jxPplN9wGBIrtkyxUXo5tpaRaTzWX0a';
  const destFolderUrl = 'https://drive.google.com/drive/folders/148LZNOxM1T5dojvNj5Zi7Y4zbsmZUDwK';
  const outputFileName = 'document-PS-manifest.pdf'; // Desired output filename
  // --- End Definitions ---

  Logger.log(`Starting PDF Merge function for: ${outputFileName}`);

  // --- Configuration Checks ---
  if (typeof PROJECT_KEY === 'undefined' || !PROJECT_KEY || PROJECT_KEY === 'YOUR_PROJECT_KEY' || 
      typeof SECRET_KEY === 'undefined' || !SECRET_KEY || SECRET_KEY === 'YOUR_SECRET_KEY') {
     Logger.log('ERROR: iLovePDF PROJECT_KEY/SECRET_KEY missing or not set.'); return; 
  }
   if (!sourceFolderUrl || !destFolderUrl || !outputFileName) {
       Logger.log('ERROR: Source folder, Destination folder, or Output filename is missing in the function.'); return;
   }
  // --- End Checks ---

  let sourceFolder, destFolder;
   try {
      sourceFolder = DriveApp.getFolderById(sourceFolderUrl.split('/').pop());
      destFolder = DriveApp.getFolderById(destFolderUrl.split('/').pop());
  } catch (folderError) {
      Logger.log(`ERROR: Could not access source or destination folder. Check IDs. Details: ${folderError.message}`); return; }

  const files = sourceFolder.getFilesByType(MimeType.PDF);
  if (!files.hasNext()) { Logger.log('No PDF files found in the source folder to merge.'); return; }
  
  try {
    const authToken = getIloveApiToken_(); // Get auth token
    const headers = { 'Authorization': 'Bearer ' + authToken };

    // === Step 1: Start Merge Task ===
    Logger.log('Starting merge task...');
    const startResponse = UrlFetchApp.fetch('https://api.ilovepdf.com/v1/start/merge', {
      method: 'get',
      headers: headers,
      muteHttpExceptions: true
    });
    if (startResponse.getResponseCode() !== 200) throw new Error(`Merge Start failed: ${startResponse.getContentText()}`);
    const startData = JSON.parse(startResponse.getContentText());
    const server = `https://${startData.server}`;
    const taskId = startData.task;
    Logger.log(`Task started with ID: ${taskId}`);

    // === Step 2: Upload Files ===
    const uploadedFiles = []; // Array to store server filenames for processing
    while (files.hasNext()) {
      const file = files.next();
      Logger.log(`Uploading file: ${file.getName()}...`);
      const uploadResponse = UrlFetchApp.fetch(`${server}/v1/upload`, {
        method: 'post',
        headers: headers,
        payload: { task: taskId, file: file.getBlob() },
        muteHttpExceptions: true
      });
      if (uploadResponse.getResponseCode() !== 200) throw new Error(`Upload failed for ${file.getName()}: ${uploadResponse.getContentText()}`);
      const uploadData = JSON.parse(uploadResponse.getContentText());
      // Add server filename and original filename to the list for the process step
      uploadedFiles.push({ server_filename: uploadData.server_filename, filename: file.getName() }); 
      Logger.log(`Upload successful for ${file.getName()}`);
    }

    // === Step 3: Process the Merge Task ===
    Logger.log(`Processing the merge for ${uploadedFiles.length} files...`);
    const processPayload = {
        task: taskId,
        tool: 'merge',
        files: uploadedFiles // Send the list of files to merge (order is determined by upload order here)
    };

    const processResponse = UrlFetchApp.fetch(`${server}/v1/process`, {
      method: 'post',
      headers: headers,
      contentType: 'application/json',
      payload: JSON.stringify(processPayload),
      muteHttpExceptions: true
    });
     if (processResponse.getResponseCode() !== 200) {
       let errorDetail = processResponse.getContentText();
       try { const errorJson = JSON.parse(errorDetail); if (errorJson && errorJson.error && errorJson.error.message) { errorDetail = errorJson.error.message; } } catch(parseError) {}
       throw new Error(`Merge Process failed (Status ${processResponse.getResponseCode()}): ${errorDetail}`);
     }
    Logger.log(`Processing successful: ${processResponse.getContentText()}`);
    
    // === Step 4: Download the Result ===
    Logger.log('Downloading the final merged PDF...');
    const downloadResponse = UrlFetchApp.fetch(`${server}/v1/download/${taskId}`, {
      method: 'get',
      headers: headers,
      muteHttpExceptions: true 
    });

    if (downloadResponse.getResponseCode() !== 200) {
        throw new Error(`Download failed with status ${downloadResponse.getResponseCode()}: ${downloadResponse.getContentText()}`);
    }
    
    const mergedPdfBlob = downloadResponse.getBlob().setName(outputFileName); // Set the desired name
    
    // === Step 5: Save to Google Drive ===
    const finalFile = destFolder.createFile(mergedPdfBlob);
    Logger.log(`SUCCESS! File "${outputFileName}" saved to destination folder: ${finalFile.getUrl()}`);

  } catch (e) {
    Logger.log(`An error occurred during merge: ${e.toString()}`);
     if (e.stack) { Logger.log(`Stack Trace: ${e.stack}`); }
  }
}
// =======================================================
// ====== Shipping Doc Merging Software Function ======
//
// This function merges all packing slips and renames 
// to today's date and moves the loose packing slip to 
// the archive folder.
// =======================================================
/**
 * Merges shipping PDFs, saves the result with a dynamic name,
 * and then moves the processed source files to an archive folder.
 */
function prepareShippingDocs() {
  // --- Define Source, Destination, and Archive ---
  const sourceFolderUrl = 'https://drive.google.com/drive/folders/148LZNOxM1T5dojvNj5Zi7Y4zbsmZUDwK';
  const destFolderUrl = 'https://drive.google.com/drive/folders/148LZNOxM1T5dojvNj5Zi7Y4zbsmZUDwK';
  
  // Updated archive folder URL
  const archiveFolderUrl = 'https://drive.google.com/drive/folders/16L13SDR6_bCFs_r6trB74GNnL4GwfxY-'; 
  
  // --- Base name for output file ---
  const outputBaseName = 'ddpos';
  // --- End Definitions ---

  // --- Configuration Checks ---
  if (typeof PROJECT_KEY === 'undefined' || !PROJECT_KEY || PROJECT_KEY === 'YOUR_PROJECT_KEY' ||
    typeof SECRET_KEY === 'undefined' || !SECRET_KEY || SECRET_KEY === 'YOUR_SECRET_KEY') {
    Logger.log('ERROR: iLovePDF PROJECT_KEY/SECRET_KEY missing or not set.');
    return;
  }
  if (!sourceFolderUrl || !destFolderUrl || !outputBaseName || !archiveFolderUrl) {
    Logger.log('ERROR: Source, Destination, Archive folder, or Output basename is missing.');
    return;
  }
  // --- End Checks ---

  let sourceFolder, destFolder, archiveFolder;
  try {
    sourceFolder = DriveApp.getFolderById(sourceFolderUrl.split('/').pop());
    destFolder = DriveApp.getFolderById(destFolderUrl.split('/').pop());
    archiveFolder = DriveApp.getFolderById(archiveFolderUrl.split('/').pop()); // Get archive folder
  } catch (folderError) {
    Logger.log(`ERROR: Could not access source, destination, or archive folder. Check IDs. Details: ${folderError.message}`);
    return;
  }

  // --- Dynamic Filename Logic ---
  const today = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyy-MM-dd");
  let index = 1;
  let outputFileName = `${today}-${outputBaseName}.pdf`; // Start with base name
  while (destFolder.getFilesByName(outputFileName).hasNext()) {
    index++;
    outputFileName = `${today}-${outputBaseName}-${index}.pdf`;
  }
  Logger.log(`Starting PDF Merge. Output file will be: ${outputFileName}`);
  
  // Regex to skip previously merged files
  const skipRegex = new RegExp(`^${today}-${outputBaseName}(-\\d+)?\\.pdf$`);
  // --- End Dynamic Filename Logic ---

  const files = sourceFolder.getFilesByType(MimeType.PDF);
  if (!files.hasNext()) {
    Logger.log('No PDF files found in the source folder to merge.');
    return;
  }

  const filesToMove = []; // Array to hold files for archiving
  
  try {
    const authToken = getIloveApiToken_(); 
    const headers = { 'Authorization': 'Bearer ' + authToken };

    // === Step 1: Start Merge Task ===
    Logger.log('Starting merge task...');
    const startResponse = UrlFetchApp.fetch('https://api.ilovepdf.com/v1/start/merge', {
      method: 'get',
      headers: headers,
      muteHttpExceptions: true
    });
    if (startResponse.getResponseCode() !== 200) throw new Error(`Merge Start failed: ${startResponse.getContentText()}`);
    const startData = JSON.parse(startResponse.getContentText());
    const server = `https://${startData.server}`;
    const taskId = startData.task;
    Logger.log(`Task started with ID: ${taskId}`);

    // === Step 2: Upload Files (with filtering) ===
    const uploadedFiles = []; 
    while (files.hasNext()) {
      const file = files.next();
      const fileName = file.getName(); 

      // --- Filter Logic ---
      const skip1 = fileName.endsWith('-SOS.pdf');
      const skip2 = fileName.endsWith('-L.pdf');
      const skip3 = skipRegex.test(fileName); 
      
      if (skip1 || skip2 || skip3) {
        Logger.log(`Skipping file (did not meet criteria): ${fileName}`);
        continue; 
      }
      // --- End Filter Logic ---

      Logger.log(`Uploading file: ${fileName}...`);
      const uploadResponse = UrlFetchApp.fetch(`${server}/v1/upload`, {
        method: 'post',
        headers: headers,
        payload: { task: taskId, file: file.getBlob() },
        muteHttpExceptions: true
      });
      if (uploadResponse.getResponseCode() !== 200) throw new Error(`Upload failed for ${fileName}: ${uploadResponse.getContentText()}`);
      
      const uploadData = JSON.parse(uploadResponse.getContentText());
      uploadedFiles.push({ server_filename: uploadData.server_filename, filename: file.getName() });
      filesToMove.push(file); // Add file to the "move" list
      Logger.log(`Upload successful for ${fileName}`);
    }

    // --- Check if any files were filtered ---
    if (uploadedFiles.length === 0) {
      Logger.log('No files in the source folder matched the filter criteria. Aborting merge.');
      return;
    }

    // === Step 3: Process the Merge Task ===
    Logger.log(`Processing the merge for ${uploadedFiles.length} files...`);
    const processPayload = { task: taskId, tool: 'merge', files: uploadedFiles };
    const processResponse = UrlFetchApp.fetch(`${server}/v1/process`, {
      method: 'post',
      headers: headers,
      contentType: 'application/json',
      payload: JSON.stringify(processPayload),
      muteHttpExceptions: true
    });
    if (processResponse.getResponseCode() !== 200) {
       let errorDetail = processResponse.getContentText();
       try { const errorJson = JSON.parse(errorDetail); if (errorJson && errorJson.error && errorJson.error.message) { errorDetail = errorJson.error.message; } } catch(parseError) {}
       throw new Error(`Merge Process failed (Status ${processResponse.getResponseCode()}): ${errorDetail}`);
    }
    Logger.log(`Processing successful: ${processResponse.getContentText()}`);

    // === Step 4: Download the Result ===
    Logger.log('Downloading the final merged PDF...');
    const downloadResponse = UrlFetchApp.fetch(`${server}/v1/download/${taskId}`, {
      method: 'get',
      headers: headers,
      muteHttpExceptions: true
    });
    if (downloadResponse.getResponseCode() !== 200) {
       throw new Error(`Download failed with status ${downloadResponse.getResponseCode()}: ${downloadResponse.getContentText()}`);
    }
    
    const mergedPdfBlob = downloadResponse.getBlob().setName(outputFileName); 

    // === Step 5: Save to Google Drive ===
    const finalFile = destFolder.createFile(mergedPdfBlob);
    Logger.log(`SUCCESS! File "${outputFileName}" saved to destination folder: ${finalFile.getUrl()}`);
    
    // === Step 6: Move Processed Files to Archive ===
    Logger.log(`Moving ${filesToMove.length} processed files to archive...`);
    let moveErrors = 0;
    
    for (const fileToMove of filesToMove) {
      try {
        // Move the file to the archive folder specified at the top
        fileToMove.moveTo(archiveFolder);
        Logger.log(`Moved: ${fileToMove.getName()}`);
      } catch (moveError) {
        // Log an error but continue the loop
        Logger.log(`ERROR: Failed to move file: ${fileToMove.getName()}. Error: ${moveError.message}`);
        moveErrors++;
      }
    }
    
    if (moveErrors > 0) {
      Logger.log(`Warning: ${moveErrors} files could not be moved to the archive.`);
    } else {
      Logger.log('All processed files moved to archive successfully.');
    }

  } catch (e) {
    Logger.log(`An error occurred during merge: ${e.toString()}`);
    if (e.stack) { Logger.log(`Stack Trace: ${e.stack}`); }
  }
}
// =======================================================
// ==== Ending Shipping Doc Merging Software Function ====
// =======================================================



// =======================================================
// ====== HELPER FUNCTIONS for iLovePDF Merging ======
// =======================================================

/**
 * Gets a fresh iLovePDF API token. 
 * (Ensure this function only exists once in your script)
 */
function getIloveApiToken_() {
  // Ensure PROJECT_KEY and SECRET_KEY are defined
  if (typeof PROJECT_KEY === 'undefined' || typeof SECRET_KEY === 'undefined' || 
      PROJECT_KEY === 'YOUR_PROJECT_KEY' || SECRET_KEY === 'YOUR_SECRET_KEY') {
     throw new Error("PROJECT_KEY or SECRET_KEY is not defined in the Configuration section.");
  }
  
  const authResponse = UrlFetchApp.fetch('https://api.ilovepdf.com/v1/auth', {
    method: 'post',
    contentType: 'application/json',
    payload: JSON.stringify({ public_key: PROJECT_KEY, secret_key: SECRET_KEY }),
    muteHttpExceptions: true 
  });
  
  const responseCode = authResponse.getResponseCode();
  const responseText = authResponse.getContentText();

  if (responseCode !== 200) {
    throw new Error(`iLovePDF Authentication failed. Status: ${responseCode}, Response: ${responseText}`);
  }
  
  const token = JSON.parse(responseText).token;
  if (!token) {
     throw new Error(`iLovePDF Authentication succeeded but no token was returned. Response: ${responseText}`);
  }
  Logger.log('Successfully obtained iLovePDF Auth Token.'); 
  return token;
}

/**
 * Helper: Converts an array of page numbers [1, 2, 4, 5, 6, 8]
 * into a range string "1-2,4-6,8" for the iLovePDF API.
 * (Ensure this function only exists once in your script)
 */
function convertPageListToRangeString_(pageNumbers) {
  if (!pageNumbers || pageNumbers.length === 0) { return ""; }
  pageNumbers.sort((a, b) => a - b); 
  let rangeString = "";
  let startRange = pageNumbers[0];
  for (let i = 0; i < pageNumbers.length; i++) {
    if (i + 1 < pageNumbers.length && pageNumbers[i+1] === pageNumbers[i] + 1) { continue; } 
    else {
      if (rangeString.length > 0) rangeString += ","; 
      if (pageNumbers[i] === startRange) { rangeString += startRange; } 
      else { rangeString += `${startRange}-${pageNumbers[i]}`; }
      if (i + 1 < pageNumbers.length) { startRange = pageNumbers[i+1]; }
    }
  }
  return rangeString;
}


// =======================================================
// ========== MENARDS GREEN LABEL CREATION   =============
// =======================================================

function generateMenardsGreenLabels() {

  const SKU_MAP = {
    "DD2083204": "DIGDE001 Vendor Part #: 2-4 Color: 4 pack Dig Defence® Small/Med Drive-In Animal Barrier (2in Spacing)",
    "DD2083210": "DIGDE001 Special Order Vendor Part #: 2-10 Color: 10 pack Dig Defence® Small/Med Drive-In Animal Barrier (2in Spacing)",
    "DD2083225": "DIGDE001 Vendor Part #: 2-25 Color: 25 pack Dig Defence® Small/Med Drive-In Animal Barrier (2in Spacing)",
    "DD3103204": "DIGDE001 Special Order Vendor Part #: 3-4 Color: 4 pack Dig Defence® Large Drive-In Animal Barrier (2.5in Spacing)",
    "DD3103210": "DIGDE001 Special Order Vendor Part #: 3-10 Color: 10 pack Dig Defence® Large Drive-In Animal Barrier (2.5in Spacing)",
    "DD3103225": "DIGDE001 Special Order Vendor Part #: 3-25 Color: 25 pack Dig Defence® Large Drive-In Animal Barrier (2.5in Spacing)",
    "DDXL152402": "DIGDE001 Special Order Vendor Part #: XL-2 Color: 2 pack Dig Defence® XL Drive-In Animal Barrier (1.5in Spacing)",
    "DDXL152405": "DIGDE001 Special Order Vendor Part #: XL-5 Color: 5 pack Dig Defence® XL Drive-In Animal Barrier (1.5in Spacing)",
    "DDXL152415": "DIGDE001 Special Order Vendor Part #: XL-15 Color: 15 pack Dig Defence® XL Drive-In Animal Barrier (1.5in Spacing)"
  };

  // 1. Get the data from the Google Sheet
  const sheet = SpreadsheetApp.openById(MENARDS_SHIPPING_CONFIG.SHEET_ID).getSheetByName(MENARDS_SHIPPING_CONFIG.SHEET_NAME);
  if (!sheet) {
    Logger.log(`Error: Sheet tab named "${MENARDS_SHIPPING_CONFIG.SHEET_NAME}" not found.`);
    return;
  }
  const data = sheet.getDataRange().getValues(); 

  // 2. Get the template file and save folder
  // --- THESE LINES WERE MISSING ---
  const templateFile = DriveApp.getFileById(MENARDS_SHIPPING_CONFIG.LABEL_TEMPLATE_ID);
  const saveFolder = DriveApp.getFolderById(MENARDS_SHIPPING_CONFIG.LABEL_SAVE_FOLDER_ID);
  // --------------------------------

  // 3. Get headers to find column positions dynamically
  const headers = data.shift();
  const col = {
    po: headers.indexOf('PKG_PACKAGE_ID'),
    name: headers.indexOf('SHPTO_NAME'),
    address: headers.indexOf('SHPTO_ADDRESS_1'),
    city: headers.indexOf('SHPTO_CITY'),
    state: headers.indexOf('SHPTO_STATE_PROV'),
    postal: headers.indexOf('SHPTO_POSTAL_CODE'),
    sku: headers.indexOf('PKG_CUSTOM1'), // This is Column M
    quantity: headers.indexOf('PKG_CUSTOM5'),
    storeNum: headers.indexOf('PKG_CUSTOM4'),
    customerName: headers.indexOf('PKG_CUSTOM3') 
  };
  
  if (col.po === -1 || col.name === -1 || col.sku === -1) {
    Logger.log("Error: Could not find required columns in sheet. Check names like 'PKG_PACKAGE_ID', 'SHPTO_NAME', 'PKG_CUSTOM1'.");
    return;
  }

  // 4. Loop through each row of data
  let generatedCount = 0;
  data.forEach((row, index) => {
    // Read the data for the current row
    let poNumber = row[col.po] || ""; 
    let storeId = poNumber.substring(0, 4); 
    let shipToName = row[col.name] || "";
    let address = row[col.address] || "";
    let city = row[col.city] || "";
    let state = row[col.state] || "";
    let postal = row[col.postal] || "";
    let sku = row[col.sku] || ""; // This gets the SKU
    let quantity = row[col.quantity] || "1"; 
    let storeNum = row[col.storeNum] || "";
    let customerName = row[col.customerName] || "";
    
    // Look up the description from the map
    let skuDescription = SKU_MAP[sku] || ""; // Gets the matching description
    
    let totalPackages = parseInt(quantity, 10);
    if (isNaN(totalPackages) || totalPackages < 1) {
      totalPackages = 1; 
    }

    for (let i = 1; i <= totalPackages; i++) {
      let currentPackage = i; 
      let newLabelName = `Label_PO_${poNumber}_SKU_${sku}_(${currentPackage}_of_${totalPackages})`;

      try {
        // ... (copy template) ...
        let newFile = templateFile.makeCopy(newLabelName, saveFolder);
        let newSlide = SlidesApp.openById(newFile.getId());
        let slide = newSlide.getSlides()[0]; 

        // 6. Replace all placeholder tags with data
        let finalName = customerName ? customerName.toUpperCase() : shipToName;
        slide.replaceAllText("{{LASTNAME,FIRSTNAME}}", finalName);

        slide.replaceAllText("{{ORDER_DATE}}", new Date().toLocaleDateString()); 
        slide.replaceAllText("{{PO_NUM}}", poNumber);
        slide.replaceAllText("{{STORE_NUM}}", storeNum);
        slide.replaceAllText("{{STORE_ID}}", storeId);
        slide.replaceAllText("{{SKU}}", sku);
        
        slide.replaceAllText("{{SKU_DESCRIPT}}", skuDescription);
        
        slide.replaceAllText("{{SHPTO_NAME}}", shipToName); 
        slide.replaceAllText("{{STORE_NAME}}", city); 
        slide.replaceAllText("{{ADDRESS}}", address);
        slide.replaceAllText("{{CITY}}", city);
        slide.replaceAllText("{{STATE}}", state);
        slide.replaceAllText("{{ZIP_CODE}}", postal);
        slide.replaceAllText("{{QUANTITY}}", quantity); 
        slide.replaceAllText("{{p1}}", currentPackage);
        slide.replaceAllText("{{p2}}", totalPackages);

        // 7. Save and create the PDF
        newSlide.saveAndClose();
        let pdf = newFile.getAs('application/pdf');
        pdf.setName(newLabelName + ".pdf");
        saveFolder.createFile(pdf);
        
        // 8. Clean up
        newFile.setTrashed(true);
        generatedCount++;
        Logger.log(`Created PDF: ${newLabelName}.pdf`);

      } catch (e) {
        Logger.log(`Error creating label for ${poNumber} (Row ${index + 2}, Pkg ${currentPackage}): ${e.message}`);
      }
    } 
  });
  Logger.log(`✅ ${generatedCount} total labels generated!`);
}



